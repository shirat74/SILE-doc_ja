\begin[papersize=a4,class=book]{document}
%\begin[papersize=152mm x 229mm,class=book]{document}
\script[src=packages/grid]
\script[src=packages/url]
\script[src=packages/autodoc]
\script[src=packages/verbatim]
\script[src=packages/color]
\script[src=packages/image]
\script[src=packages/rotate]
\script[src=packages/unichar]
\script[src=packages/frametricks]
\script[src=packages/lorem]
\script[src=packages/bidi]\bidi-off
\script[src=packages/pdf]
%\script[src=packages/pullquote]
\include[src=documentation/macros.sil]
\define[command=silehp]{\url{http://www.sile-typesetter.org/}}
\define[command=sileversion]{\script{SILE.typesetter:typeset(SILE.version)}}
\font[size=10pt, language="ja", family="Yu Mincho", weight="300"]
\nofolios
%\set[parameter=document.lskip,value=5em]
%\set[parameter=document.rskip,value=5em]
\par\center{\font[size=50pt,weight=600,family=Arial]{The}\par
\center{\img[src=documentation/sile-logo.pdf,height=40mm]}\par
\font[size=50pt,weight=600,family=Arial]{Book}}
\bigskip
\font[size=12pt,family=Arial]{\hss for SILE version \sileversion \hss \par}
\skip[height=1in]
\skip[height=1in]
\font[size=20pt,weight=600,family=Arial]{\hss Simon Cozens \hss \par}
%
%\set[parameter=document.lskip,value=0]
%\set[parameter=document.rskip,value=0]
\set[parameter=document.parskip,value=4pt plus 1pt]
\set[parameter=document.parindent,value=1em]
\set[parameter=document.baselineskip,value=1.8em]
\open-double-page
\tableofcontents
\set-counter[id=folio,value=0]
\chapter{SILEとは?}

SILEは組版システムです。その目的は美しい文書を生成することにあります。SILEとは何なのか、それが何をするものなのか、これらを理解する最も良い方法は、あなたが聞いたことがあるであろう他のシステムと比較することでしょう。

\section{SILEとWord}

多くの人たちはパソコンを使って印刷用の文書を作成するとき、Microsoft Word、iWork Pages、あるいはLibreOffice Writerといった、デスクトップ向けのワープロソフトを利用します。SILEはこれらワープロソフトとは異なります。それは組版システムです。そこにはいくつかの重要な違いがあります。

ワープロソフトの目的は、あなたがスクリーン上で入力しているものと、そっくりそのまま同じ見た目の文書を作成することにあります。これに対して、組版システムの仕事は、ユーザの生の入力データから、可能な限り見栄えの良い文書を生成することにあります。SILEに対する入力データは、その内容がどのようにページ上にレイアウトされるべきかの指示を含む、テキスト文書です。

ワープロソフトはしばしばWYSIWYG—What You See Is What You Get（見たままが得られる）—であると言われますが、SILEは全くWYSIWYGでは\em{ありません}。実際、結果はそれが得られるまで分からないのです。むしろ、SILE文書は\em{テキストエディタ}—その見栄えではなく、テキストそのものを編集するためのソフトウェア—を用いて準備され、PDF文書を生成するためにSILEによって処理されます。

少し具体的にみてみましょう。ワープロソフトでは、あなたはどんどん文章を入力していきます。そしてそれが行の右端にさしかかると、カーソルは自動的に次の行の先頭にジャンプします。ワープロソフトはどこで改行がなされるかをあなたに示してくれます。一方SILEでは、あなたがSILE文章を入力している段階では、どこで改行が行われるかは分からず、文書をSILEが処理する段階になってそれがはっきりします。あなたは好きなだけ長い文章を、テキストエディタを使って打ち込んでいくことができます。SILEはそれを処理する段階になって、文章を整形し、パラグラフを構築するために、文章の最適な改行位置を探します。この処理はひとつの入力に対して（最大で）3回行われます。例えば、最初の試みで得られた文章の整形結果で、ふたつの連続した行がハイフネートされた語で終わっているなどの状況が生じると、より良い改行位置が見つかるよう処理が再度試みられます。

ページ分割に対しても同様です。ワープロソフトではいずれあなたは新しいページに移動することになりますが、SILEでは入力自体は好きなだけ継続されます。文章がどのようにページに分割されるかは文書全体のレイアウトを検討したのちに決定されるからです。

言い換えると、SILEはあなたが求める結果を記述するための\em{言語}であり、そのインタプリタです。SILEはあなたが与えた一連の指示に基づき、印刷物を得るための最善の処理を施します。

\section{SILEとTeX}

いくらかの人たちは、なんだかTeXのようだ、と思うかもしれません。\footnote{ひとりのTeXユーザとして言わせれば「なんだかT\glue[width=-.1667em]\lower[height=0.5ex]{E}\glue[width=-.125em]Xのようだ」だろうか。}もしあなたがTeXについてよく知らない、あるいは関心がないのであれば、このセクションは読み飛ばしてもらっても構いません。

実際、TeXのようだというのは正しい意見です。SILEはTeXからかなりのものを引き継いでいます。SILEのような小さなプロジェクトが、TeXという、『The Art of Computer Programming』の著者たるあの教授の、偉大な創造物の後継者だと名乗るのはおこがましいかもしれませんが\dots{}SILEはTeXの現代的な再実装です。

TeXは組版システムのなかでも最初期のもののうちのひとつで、それゆえほとんど何もないところから設計されなければなりませんでした。そのときなされた、設計上の決定のいくつかは時の試練に耐えました。そしてTeXはその創造から30年以上たった今でも最もよく利用される組版システムのうちのひとつであり、それはその設計とパフォーマンスの証でもあります。しかしながら、その設計の残りの多くの部分は生き残りませんでした。実際、Knuthの時代より続くTeXの発展の歴史の大半は、彼の元々の設計を取り除き、新たな業界標準技術で置き換えることでした。例えば、我々はMETAFONTではなくTrueTypeフォントを使い（xetexのように）、DVIではなくPDFを使い（pstexやpdftex）、7ビットのASCIIではなくUnicodeを使い（これもxetex）、マクロ言語ではなくマークアップ言語や組込みのプログラミング言語を使います（xmltexやluatex）。現在、我々が\em{依然として利用する}TeXのオリジナルの部分は、⑴ボックスとグルー・モデル、⑵ ハイフネーション・アルゴリズム、⑶改行（行分割）処理アルゴリズムです。

SILEは時の試練に耐え抜いた上記3つの点をTeXからしっかりと受け継いでいます。SILEはTeXの改行処理アルゴリズムのほぼ丸写しな移植を含み、それは同じ入力が与えられたとき、TeXと全く同じ出力が得られるようにテストされています。しかしながら、SILE自身がスクリプト言語で書かれているため、\footnote{もしもあなたが\code{TeX capacity exceeded}というメッセージに馴染んでいるならば、これはさぞかし興味深いことでしょう。}SILEの組版エンジンの動作を拡張したり、変更したりすることが容易にできます。

例えばTeXが苦手とすることのひとつとして、グリッド上での組版があります。この機能は聖書を組むような人にとっては重要なものです。グリッド上での組版では、紙の両面で行が同じ位置に揃います。これは薄い紙に印刷されるときの、インクの滲みによる影響を抑えるために有効です。TeX上でこれを行う試みはなされてきましたが、どれもひどいものでした。SILEでは組版エンジンの動作を変更し、ごく簡単なアドオンパッケージを用意することでグリッド上での組版を可能にします。

もちろん、いまどきだれもplain TeXを使いません—だれもがLaTeXで同様のことを行い、そのうえCTANから入手可能な巨大なパッケージ群を活用しています。SILEは未だTeXが持つような巨大なコミュニティやリソースを持たず、そのようなものを活用することができません。この点においてTeXはSILEよりもずっと先を行っています。しかし、\em{中核となる能力}という点において、TeXと同等か、あるいはもっと進んでいるとも言えるところがあるかもしれません。
\supereject

\section{SILEとInDesign}

人々が出版物をデザインするとき辿りつくツールとして、InDesign（あるいはそれと似たDTPソフト、例えばScribus）があります。

\float[rightboundary=7pt, bottomboundary=15pt]{\img[src=documentation/fig1.png,width=150]}
DTPソフトとワープロソフトは、どちらもグラフィカルでWYSIWYGである点ではよく似ています。しかし、そのパラダイムは異なります。DTPソフトでは通常、文書の内容を準備することよりも、ページ上でそれをレイアウトすることに焦点が置かれます—クリックやドラッグといったマウス操作でテキストや画像をスクリーン上で移動させます。

InDesignは複雑で高価な商用出版ツールですが、SILEは自由なオープンソースの組版ツールで、完全にテキストベースです。SILEではエディタでコマンドを入力し、それらのコマンドをファイルに保存し、SILEに組版させるために渡します。これらの根本的な違いにかかわらず、この2つには共通した特徴があります。

InDesignでは文章はページ上の\em{フレーム}に流しこまれます。左の図はInDesignでよくあるレイアウトがどのようなものかを示しています。

SILEもまたページ上でどこに文章が表示されるべきかを、フレームという概念を用いて決定します。そのためSILEではTeXでできうるよりもっと複雑で柔軟なページレイアウトを設計することが可能です。

InDesignで有用な機能として、構造化されたXMLデータ形式を用いたカタログや名簿などの出版があります。InDesignでこれを行うには、まずそれぞれのXML要素にどのようなスタイルが適用されるか宣言します。データがInDesignに読み込まれると、InDesignは与えられたルールに従ってデータを整形し出力します。

あなたは全く同じことをSILEでできるのです。ただしSILEではXML要素がどのように整形されるのかをより詳細に制御することができ、これはSILEではあなたがXML要素を処理するのに、例えばLuaコードを呼び出したりすることができるからです。SILEはコマンドラインのフィルタープログラムであるため、適切な指示が与えられれば、XMLファイルからPDFへ、いとも簡単に変換することができます。これは素晴らしいことです。

この解説書の最後の章では、複雑なXML文書をスタイル付してPDFを生成するための\em{クラスファイル}のいくつかの例を示します。

\section{結論}

SILE\footnote{一応言っておくと、著者は/saɪəl/と発音します。「trial」と韻を踏んで。}は入力として与えられたテキストの指示をもとにPDFを出力します。SILEはTeXとInDesignにインスパイアされた機能を持ち、かつより柔軟で拡張可能、プログラム可能なものを目指しています。この文書（これはSILEで書かれています）のようなものを作成したり、構造化されたデータを整形して出力するシステムとして有用です。

\chapter{さあ始めよう}

さて、SILEとは何か、何をするものなのか、いくらか理解したところでSILEそのものについて話題を移しましょう。

\section{基本的なSILE文書}

SILEをどうやって使用するのか示す前に、SILE文書がどのようなものなのかひとつ例を示しましょう。
これはSILEに対する入力であり、SILEによって処理されPDFファイルへと変換されるものです。

\note{これらの文書はプレーンテキストです。あなたがあなた自身のSILE文書を作成するにはテキストエディタが必要です。Wordのようなワープロソフトでこれらのファイルを作成しても、うまくいきません。この場合、プレーンテキストではなく、ワープロソフトの独自フォーマットで保存されてしまうからです。AtomやSublime TextのようなクロスプラットフォームのGUI指向の良いテキストエディタがあります。また、\em{Vim}や\em{Emacs}などのキーボードコマンド中心で操作するものも良いでしょう。環境によってはほかにも良い選択肢があります。WindowsではNotepad+、OS XではTextMate、GnomeのGedit、KDEではKateなどです。テキストエディタの比較については、\url{http://alternativeto.net/tag/text-editor/}を参照してください。}

とりあえず、もっとも簡単なSILE文書から始めましょう。

\begin{verbatim}
\line
\\begin[papersize=a4]\{document\}
Hello SILE!
\\end\{document\}
\line
\end{verbatim}

今のところは、SILE文書はこのようなものだというだけにしておいて、詳細は次の章で取り上げましょう。

分かり切ったことを言うようですが、これは左上部に\examplefont{Hello SILE}と書かれ、ページ番号（1）がページ下部中央に配置されたA4サイズのPDF文書を生成します。さて、どうやってそのPDFを得るのでしょうか？

\section{インストール}

なにはともあれ、あなたはSILEを手に入れ、あなたのパソコンで走らせなければなりません。SILEはホームページ\silehpから入手できます。

\subsection{パッケージのインストール}

OS Xでは推奨されるSILEのインストール方法は、Homebrewパケージマネージャを利用することです。Homebrewが利用できる環境では（\url{http://brew.sh}を参照）、SILEをインストールするのはごく簡単です。

\listitem{\code{brew install sile}}

もし、あなたがこれまでLuaプログラムを使ったことがないのであれば、いくつかの依存するソフトウェアを手動で導入するように求められることでしょう。この場合、提示されたコマンドを実行した後、上記のインストールコマンドを再び実行するとインストールは完了です。

SILEのパッケージでは、最新のGit HEADバージョンをコンパイルして導入することも可能です。最新のリリースされていないコードを試すには、

\listitem{\code{brew install sile --HEAD}}

Linuxユーザには、Arch Linux用のパッケージ構築用のファイルが利用可能です。\code{sile}パッケージは最新の安定版で、\code{sile-git}はリリースされていない最新のコードをGitレポジトリから取得し、構築します。もし、あなたが、AURをサポートしたパッケージマネージャを利用しているのであれば、いつものように、いずれかのパッケージを導入できます。

\listitem{\code{yaourt -S sile}}

その他のシステムでは、あなた自身でソースコードをダウンロードし、コンパイルする必要があります。

\subsection{ソースからのインストール}

SILEをインストールし、実行するにはいくつか他のソフトウェアが必要です—Luaプログラミング言語のインタプリタとHarfbuzzテキストシェーピング・ライブラリです。SILEにはそれ自身のPDF生成ライブラリが付属しており、それもまたいくつかのライブラリを要求します。\code{freetype}、\code{fontconfig}、\code{libz}、そして\code{libpng}です。

これらの依存ライブラリをそろえる際には、あなたが利用しているディストリビューションのパッケージマネージャを極力使うようにしてください。DebianやUbuntuのようなDEBベースのLinuxマシンでは、以下のコマンドで必要なものを一式導入することができるでしょう。

\listitem{\code{apt-get install liblua5.2-dev lua-expat lua-lpeg libharfbuz-dev libfreetype6-dev libfontconfig-dev libpng-dev}}

RedHat系のLinuxディストリビューションでは、

\listitem{\code{yum install harfbuzz-devel make automake gcc freetype-devel fontconfig-devel lua-devel lua-lpeg lua-expat libpng-devel}}

これらの依存ライブラリがインストールされれば、次はLuaライブラリをそろえる必要があります。まだインストールされていない場合は入れましょう。

\listitem{\code{luarocks install lpeg}}
\listitem{\code{luarocks install luaexpat}}
\listitem{\code{luarocks install luafilesystem}}

以上のことが済めばようやく本題に移れます。SILEのホームページからダウンロードしたファイルを解凍し、ディレクトリを移動してから\footnote{もしあなたが、リリースされた配布物を取得したのではなく、Gitレポジトリをクローンしたのであれば、次のステップに進む前に\code{./bootstrap.sh}を実行する必要があるでしょう。}、以下を実行します。

\listitem{\code{./configure; make}}

これが終わればSILEを未インストールの状態で実行できます。

\listitem{\code{./sile examples/simple.sil}}

すべてが順調であれば、\code{examples/simple.pdf}というファイルが生成されるはずです。

SILEを本格的に使うには\code{sile}コマンドとSILEライブラリ・ファイルをシステムにインストールします。これを行うには次のようにします。

\listitem{\code{make install}}

これで\code{sile}コマンドがどのディレクトリからも利用可能になりました。

\subsection{Windowsユーザのためのノート}
Windowsでも\code{mingw32}環境でSILEを動作させることができたとのユーザからの報告があります。現在のところ、確実な方法はありませんが、\url{https://github.com/simoncozens/sile/issues/82}での議論が参考になるでしょう。

\section{SILEの実行}

では新たなディレクトリに移り、テキストエディタを開いて先ほど例示した内容をファイル\code{hello.sil}に保存しましょう。そしてコマンドを実行します。

\listitem{\code{sile hello}}

（SILEは引数のファイル名に拡張子が与えられなければ、自動的に拡張子\code{.sil}を追加します）

これによってファイル\code{hello.pdf}ができるでしょう。あなたはめでたくSILEでの最初の文書を作成することができました。

\section{もうちょっとクールに}

\code{examples/article-template.xml}は典型的なDocBook 5.0文書です。DocBookを印刷する場合、しばしば、XSLTプロセッサ、FOプロセッサ、そして場合によっては奇妙なLaTeXパッケージに振り回されなければなりません。しかし、SILEはXMLファイルを読み込むことができ、しかもDocBook（実際にはそのサブセット）を処理するための\code{docbook}クラスが付属しています。

例、\code{examples/article-template.xml}を\code{examples/article-template.pdf}に変換するには、単純にこうします。

\begin{verbatim}
\line
\% \em{./sile -I docbook examples/article-template.xml}
This is SILE \sileversion
Loading docbook
<classes/docbook.sil><examples/article-template.xml>[1] [2] [3]
\line
\end{verbatim}

ここで\code{-I}フラグは入力ファイルを読み込む前に\em{クラス}ファイルを読み込むための指示です。 \code{docbook}クラスファイルが読み込まれたのち、DocBookファイルは直接読み込まれ、タグはSILEコマンドとして解釈されます。

第10章では\code{docbook}クラスがどのようなものか見てみます。そこでは他のXMLフォーマットをいかに処理するか学ぶでしょう。

\chapter{SILE文書の作成}

さて、ここで最初の例に戻りましょう。

\begin{verbatim}
\line
\\begin[papersize=a4]\{document\}
Hello SILE!
\\end\{document\}
\line
\end{verbatim}

文書は\code{\\begin\{document\}}コマンドで始まります。それには用紙サイズの指定が\em{必須}です。そして文書は\code{\\end\{document\}}で終わります。その間には2種類のSILE文書を構成する要素が来ます。ページ上に出力されるテキスト、ここでは“Hello SILE!”、とコマンドです。

\note{\notehead{用紙サイズ}
SILEは国際規格ISOのA・B・Cシリーズの用紙サイズを認識します。これに加えて次の伝統的によく用いられる用紙サイズも利用可能です。letter、note、legal、executive、halfletter、\goodbreak{}halfexecutive、\goodbreak{}statement、folio、quarto、ledger、tabloid。

もしも標準的でない用紙サイズを指定したければ、具体的なサイズを直接指定することも可能です。\code{papersize=\em{<basic length> x <basic length>}}。

\smallskip\notehead{単位}\par
SILEでは長さを指定するいくつかの方法があります。上記\code{<basic length>}は数と単位（の省略記号）の指定からなります。認識される単位はポイント（\code{pt}）、ミリメートル（\code{mm}）、センチメートル（\code{cm}）、インチ（\code{in}）です。例えば、ペーパーバックサイズのB-formatは\code{papersize=198mm x 129mm}のように指定されます。後ほど長さを指定する別の方法についてもみることとなるでしょう。}

\section{テキスト}

通常のテキストについてはこれといって述べることはありません。単に入力してください。

\note{TeXユーザーはSILEがテキストについても何らかの処理を行うものと期待するかもしれません。例えば、あなたがTeXにおいて、ふたつの連続したバッククォート（\code{``}）を入力すると、TeXはそれを開始用のダブルクォート（“）に置き換えてくれます。SILEはそのようなことは行いません。ダブルクォートを入力してください。同様にenダッシュとemダッシュでも、\code{--}や\code{---}ではなく、Unicodeで該当する文字を入力してください。}

テキスト処理においていくつか挙げる点があるとすれば以下のものでしょうか。

まずひとつ目は、スペースの扱いについてです。もしあなたがスペース3つを用いて\code{Hello {} {} SILE!}と書いたとしても、それはスペース1つ分、\code{Hello SILE!}と同じ結果になります。また、行の先頭にあるスペースは無視されます。

同様に、改行文字を好きなところに入れることができます。\footnote{訳注：わかち書きをする言語ではです。改行文字はスペース1個分と同じように扱われます。}SILEはパラグラフ全体を取扱い、与えられた行長で可能な、最適な改行位置を計算します。例として挙げるならば、あなたの入力が仮に

\begin{verbatim}
\line
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
\line
\end{verbatim}

\noindent{}だったとしても、SILEの出力において‘eiusmod’で改行が起こるとは限りません。改行は常に、適切な位置で行われます。実際の出力は以下のようなものとなるでしょう。

\line
\nohyphenation{\examplefont{\quad{}Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.}}
\line

言うならば、改行文字はスペースに変換されます。（場合によってはこれは望ましいことではありません。もし行の終わりに余分なスペースを加えたくなければ、行の末尾でコメント文字\code{\%}を使います）

パラグラフを終了する場合は、改行を2個続けて入れてください。例えば、

\begin{verbatim}
\line
Paragraph one.

Paragraph two.
This is not paragraph three.

This is paragraph three.
\line
\end{verbatim}

注意点として挙げられるふたつ目は、いくつかの（４つです）文字はSILEでは特別な意味を持つことです。これらはTeXユーザにとっては馴染み深いものでしょう。

\em{バックスラッシュ}はコマンドの開始に用いられます。（コマンドの詳細については後ほどすぐに述べましょう）\em{波括弧} （\code{\{}と\code{\}}）はグループ化に、特にコマンドの引数を扱う際に用いられます。最後に\em{パーセント記号}はコメント行の開始として用いられます。パーセント記号から次の改行文字まではSILEによって無視されます。これらの文字を出力したければ、バックスラッシュを前に付けましょう。\code{\\\\}は‘\\’\footnote{訳注：フォントによっては円記号になってしまいます。}を、\code{\\\{}は‘\{’を、\code{\\\}}は‘\}’を、そして\code{\\\%}は‘\%’を出力します。

3つ目の点はハイフネーションです。SILEはそれによってパラグラフ全体の見た目が良くなると判断できるときはいつでも、自動的に語をハイフネートして改行します。ハイフネーションはその時の言語の設定が反映されます。特に指定がなければ、SILEはデフォルトで英語を仮定し、ハイフネーション処理を行います。上記のラテン語のテキストの例ではハイフネーションは無効化されています。

最後に挙げる点はリガチャです。（ふたつあるいはそれ以上の文字が、見た目を良くするために、ひとつの文字に結合される）SILEは自動的にリガチャ処理を行います。このため、あなたがもし\code{affluent
fishing}と入力すると（実際には使用するフォントに依存します）、出力結果は‘\examplefont{affluent fishing}’のようになります。リガチャを抑制したい場合は、空のグループ（グループ化文字\code{\{}と\code{\}}を使って）を挿入します。\code{af\{\}f\{\}luent f\{\}ishing}では\examplefont{af{}f{}luent f{}ishing}のようになります。リガチャやそのほかの機能の制御に関する詳細については\em{OpenTypeフィーチャ}の節を参照してください。

\section{コマンド}

典型的な（この点に関しては後ほど再検討しましょう）SILEコマンドは、バックスラッシュで始まり、コマンド名が続く文字列です。そして文書は\code{\\begin\{document\}}コマンドで始まり、\code{\\end\{document\}}で終わります。

コマンドはまた、ふたつの必須でない部分を持ちます。それはパラメータと引数です。文書を開始する時の\code{\\begin}コマンドはその良い例です。\footnote{厳密に言うと\code{\\begin}はコマンドではありませんが、とりあえず今はそういうことにしときましょう。}

\begin{verbatim}
\line
\\begin[papersize=a4]\{document\}
\line
\end{verbatim}

コマンドのパラメータは角括弧で囲まれ、\code{\em{key}=\em{value}}の形をとります。\break{}複数のパラメータを指定する場合は、コンマやセミコロンを使って、\code{[key1=value1,key2=value2,\dots]}のように続けます。"key"の前後のスペースは重要ではありません。\code{[key1 = value1; key2 = value2; \dots]}のように書くこともできます。もしもコンマやセミコロンをパラメータの値に使いたければ、引用符で値全体を囲います。\code{[key1 = "value1, still value 1", key2 = value2; \dots]}のように。

コマンドは引数をとるかもしれませんが、その場合は波括弧で囲います。\footnote{TeXユーザはつい括弧を忘れてしまうかもしれませんが、それはいけません。SILEでは括弧は必須です。}

SILEはコマンド直後のスペースや改行文字を無視します。

以下にいくつかのSILEコマンドを示しましょう。

\begin{verbatim}
\line
\\eject                                 \% A command with no parameters or argument

\\font[family=Times,size=10pt]          \% Parameters, but no argument

\\chapter\{Introducing SILE\}               \% Argument but no parameters

\\font[family=Times,size=10pt]\{Hi there!\} \% Parameters and argument
\line
\end{verbatim}%
\section{環境}

\code{\\chapter}や\code{\\em} (イタリック体による強調)といったコマンドは、せいぜい数行の比較的短いテキストを囲むために用いられます。もっと長い、文書の一部を構成する部分を囲みたい場合は、\em{環境}を使います。環境は\code{\\begin\{\em{name}\}}で始まり、対応する\code{\\end\{\em{name}\}}までをその中に含みます。ひとつの例が既に出ていますね。\code{document}環境で、これは文書\em{全体}を囲みます。

内緒ですが、コマンドと環境の間には全く違いはありません。いうなれば、以下のふたつは等価なのです。

\begin{verbatim}
\line
\\font[family=Times,size=10pt]\{Hi there!\}

\\begin[family=Times,size=10pt]\{font\}
Hi there!
\\end\{font\}
\line
\end{verbatim}

しかしながら、いくつかの場面では、環境を用いたほうが読みやすく、どこからどこまでコマンドが影響するのか認識しやすくまります。

\section{XML書式}

実際のところ、SILEはこれまで示したものとは完全に異なる入力フォーマットを受け付けます。
これまで例示してきたのもは「TeX風書式」でしたが、もし入力ファイルの最初の文字が山括弧（実際は不等号記号\code{<}）であった場合は、SILEは入力ファイルがXML書式であると捉えます。［もしそれが整形式の（well-formed）XML文書でなければ、SILEは非常に機嫌を損ねるでしょう］

入力ファイル中のすべてのXMLタグは、SILEコマンドであると解釈され、属性はパラメータであるとみなされます。このため、ふたつのファイルフォーマットは実際的には等価です。ただひとつの例外を除いては。XML書式の場合はSILE文書は\em{任意の}タグで始まってもよいのです。（習慣としてSILE文書には\code{<sile>}を用いるのが好ましいですが）

例えば、XML形式で前述の例文を示すと、

\begin{verbatim}
\line
<sile papersize="a4">
Hello SILE!
</sile>
\line
\end{verbatim}

引数を取らないコマンドはすべて整形式のself-closing\footnote{訳注：適切な訳語が分からないが、開始・終了のペアではなく、単体で存在するタグのこと。}タグ（例えば\code{<break/>}）でなければならず、パラメータ付のコマンドはその属性が整形式でなければなりません。前に挙げた例をXML書式で書くと、

\begin{verbatim}
\line
<font family="Times" size="10pt">Hi there!</font>
\line
\end{verbatim}

XML書式は人間が直接書くことを想定しているわけではありませんが—TeX風書式のほうがそれには向いているでしょう—XML書式に対応することは、コンピューターでSILEを扱うのをより容易にします。例えばSILE文書を編集するためのGUIインターフェイスを作ったり、他のXML書式をSILEのそれに変換したり。

しかしながら、SILEにおいてはXML文書を処理するためのよりスマートな方法が存在します。そのためには、あなたはあなた自身のSILEコマンド、それは非常に単純な文書整形用のものからSILEの動作を根本から変えるものまでを含む、を定義できることを知る必要があります。あなたがある特定のXML形式のファイル—仮にDocBookとしましょう—を持っているとします。あなたはすべての可能なDocBookタグに対するSILEコマンドを定義します。するとあなたのDocBookファイルはSILE入力ファイルとしてそのまま使えるようになるのです。

最後の2章では、SILEコマンドを定義とXML文書を処理する例を示しましょう。

\chapter{SILEコマンド}

さて、それではSILEの具体的な使用法について見ていきましょう。まずはあなたがSILEで文書を作成し始めるのに最も役立つコマンドから始め、次第により細かな点について進んでいきます。

\section{フォント}

テキストの見た目を変えるもっとも基本的なコマンドは\code{\\font}コマンドです。これは次のような書式をとります。

\noindent{}• \code{\\font[\em{parameters\dots}]\{\em{argument}\}}

\noindent{}• \code{\\font[\em{parameters\dots}]}

最初の書式では引数として与えられたテキストを指定されたフォントで描画します。次の書式ではそれ以降のテキストすべてに影響します。

例として挙げると、

\begin{verbatim}
\line
Small text

\\font[size=15pt]%
Big text!

\\font[size=30pt]\{Bigger text\}

Still big text!
\line
\end{verbatim}

\noindent{}は

\begin{examplefont}%
\line%
Small text

\noindent\font[size=15pt]%
Big text!

\noindent\font[size=30pt]{Bigger text}

\noindent{}Still big text!
\line
\end{examplefont}

\noindent{}となります。

\font[size=10pt]%

ここで見たように、属性として可能なものとして、\code{size}があります。これは、\code{<dimension>}で指定されます。ここで、\code{<dimension>}は以前登場した\code{<basic length>}のようなものですが、これは現在のフォントのサイズに対する相対的な値として指定可能です。例えば、exユニット（\code{ex}）、であったり、emユニット（\code{em}）、あるいはenユニット（\code{en}）です。


\code{\\font}コマンドで指定可能な属性値は、

\medskip

\noindent{}• \em{size}－先に述べたとおりです。

\noindent{}• \em{family}－使用するフォント名が来ます。フォントをその名前で指定するには、SILEはシステムにインストールされたすべてのフォントについて知る必要があります。SILEのXML書式では、フォントファミリーはCSS形式のコンマで分離された‘スタック’として指定可能です。

\noindent{}• \em{style}－\code{normal}または\code{italic}です。

\noindent{}• \em{weight}－CSS形式のウェイトを表す数値が来ます。有効な値は\font[weight=100]{100}と\font[weight=200]{200}から\font[weight=300]{300}、\font[weight=400]{400}、\font[weight=500]{500}、\goodbreak\font[weight=600]{600}、\goodbreak\font[weight=700]{700}、\font[weight=800]{800}、\font[weight=900]{900}までです。フォントによっては全てのウェイトがサポートされているとは限りませんが（ふたつ程度かもしれません)、SILEは最も近いものを選択します。

\noindent{}• \em{language}－2文字からなる（ISO639-1）言語コードです。これはスペーシングとハイフネーションの両方に影響を与えます。

\noindent{}• \em{script}－スクリプト（文字体系、用字系）の指定です。後で述べる「言語とハイフネーション」の節を参照してください。
\medskip

手動で陽にフォント指定を行うのは非常に面倒ですね。後ほどこれを自動化する方法についても見てみましょう。SILEは\code{\\em\{\dots\}}コマンドを\code{\\font[style=italic]\{\dots\}}のショートカットとして提供します。ボールド体に対するショートカットはありません。なぜならそれはあまり良い習慣とは言えないからです。そのようなものを簡単に行う方法は与えないことにしましょう。

\section{文書構造}

SILEは様々な文書\em{クラス}（LaTeXのクラスと似た）を提供します。デフォルトでは、文書の構造化をごくわずかにサポートするのみの、\em{plain}クラスが用いられます。他には\em{book}クラスがあり、これは左右のページマスタ、ヘッダと脚注、章、節などのヘッディング（柱）をサポートします。

この節のコマンドを使うには、あなたの文書の\code{\\begin\{document\}}コマンドで\em{book}クラスを指定する必要があります。あなたが今読んでいるこの文書は実際に、\code{\\begin[papersize=a4,class=book]\{document\}}で始まります。

\subsection{章と節}

あなたは文書を\code{\\chapter\{\dots\}}、\code{\\section\{\dots\}}、そして \code{\\subsection\{\dots\}}などのコマンドを使って分割することができます。これらのコマンドは引数として、その章や節の見出しをとります。章は新たな左ページから始まり、章の見出しは左ページのヘッダに表示されます。加えて、節の見出しは右ページのヘッダに表示されます。

\note{章や節は自動的に１から番号付けされて開始されます。この動作を変更するには、次の章の\code{counters}パッケージの解説を参照してください。番号付けを抑制したければ、パラメータ\code{[numbering=no]}を与えます。}

この副節はコマンド\code{\\subsection\{}章と節\code{\}}で開始されています。

\subsection{脚注}

脚注は\code{\\footnote\{\dots\}}コマンドでつけることができます。\footnote{このように。 \code{\\footnote\{}このように\code{\}}。}脚注コマンドに対する引数はページ下部に表示される脚注の内容です。これは各章ごとに、自動的に１から番号付けされます。

\section{インデントとスペーシング}

SILEでは、パラグラフは通常インデントされます（デフォルトで20ポイント幅です）。これを抑制するには\code{\\noindent}コマンドを、パラグラフの先頭に付与します。(このパラグラフのような、最初のパラグラフでは\code{\\noindent}は必要ありません。なぜなら\code{\\section}と\code{\\chapter}は自動的に、章や節の見出しに続く文章に対してそれを呼ぶからです）\code{\\noindent}は\code{\\indent}コマンドを続けて呼ぶことで打ち消すことができます。

パラグラフ間、あるいはパラグラフと他の要素との間の垂直方向のスペース分量を増やすには、 \code{\\smallskip}、\code{\\medskip}および\code{\\bigskip}が使えます。これらはそれぞれ、3pt、6pt、12ptのスペースに相当します。このパラグラフの後に\code{\\bigskip}を入れてみましょう。

\bigskip%
水平方向のスペースを行ないに挿入するには、小さなものから大きなものへ順に、\code{\\thinspace} （emの1/6）、\code{\\enspace}（1en）、\code{\\quad} （1em）、そして\code{\\qquad}（2em）。

\begin{center}
\code{center}環境中（\code{\\begin\{center\} \dots \\end\{center\}}）では中央寄せとなります。 例えばこのパラグラフのように。
\end{center}

\section{分割}

SILEは行とページの分割を自ら決定します。後の章ではこのプロセスを微調整する\em{設定法}を紹介しましょう。しかしながら、SILEのplainクラスにもそれを助けるためのいくつかの方法が存在します。

パラグラフ間に挿入された\code{\\break}コマンドは\em{フレーム分割}を引き起こします。（\code{\\framebreak}と\code{\\eject}という同義のコマンドも存在します）もし、複数のフレームがページ内にあれば、—例えば、多段組みの文書—現在のフレームが終了し、次のフレームの先頭から処理は続けられます。\code{\\pagebreak}（あるいは\code{\\supereject}）はより強制力のあるもので、これはページ上に更なるフレームが残っていても新しいページを開始します。より穏やかな変種としては、\code{\\goodbreak}、これはSILEにそこが良いページ分割点であると教えるもの、があります。それとは反対に、\code{\\nobreak}は分割を抑止する働きがあります。これらの中間的なものとして、\code{\\allowbreak}があり、SILEにページやフレームの分割に適さないかもしれないが、それを許可するよう指示するものとして利用できます。

パラグラフの\em{中}では、これらのコマンドは全く別の意味を持ちます。\code{\\break}コマンドは改\em{行}を指示し、\em{同様に}、\code{\\goodbreak}、\code{\\nobreak}、および\code{\\allowbreak}も行分割に対応します。もしも\em{ページ分割}を特に禁止したければ、\code{\\novbreak}を使います。

\begin{raggedright}
SILEは通常、両端揃えを行います—すなわち、SILEは一行がちょうど与えられた行長でぴったり収まるように単語間のスペースを調整します。\footnote{これはSILEが、常に一行の長さを行長に厳密に合うようにするということを意味しません。SILEはある程度の調整を行いますが、最善を尽くした後、最も悪くないと思われる結果を出力します。いくつかの語がわずかに余白に突き出る結果となることもあります。}両端揃え以外には左揃えがあります。左揃えでは単語間のスペースは均等になるかわり、パラグラフの右端はきれいに揃いません。左揃えはしばしば子供向けの本に用いられたり、新聞のような一行の幅が狭い状況でも用いられます。左揃えを行うには、文章を\code{\\begin\break\{raggedright\}}環境を囲います。このパラグラフは左揃えで組まれています。
\end{raggedright}

\begin{raggedleft}
同様に、\code{raggedleft}環境もあります。これはパラグラフの右側は揃え、逆に左はがたつきます。 このパラグラフは右揃えで組まれています。\par
\end{raggedleft}

\section{言語とハイフネーション}

SILEは現在選択されている言語の設定に基づいてハイフネーションを行います。（言語設定は前に見たように\code{\\font}コマンドで行います）SILEは様々な言語のハイフネーションをサポートしています。また、その言語特有の組版ルールについてもサポートすることを目的としています。

SILEはまた、\code{xx}という特別な「言語」、を理解します。これはなんのハイフネーションパターンもないものです。この言語に切り替えると、ハイフネーションは行われません。コマンド\code{\\nohyphenation\{\dots\}}が\code{\\font[language=xx]\{\dots\}}のショートカットとして利用できます。

ハイフネーション以外にも、言語ごとに組版上の規則は異なりますが、SILEはほとんどの言語とスクリプトに対する基本的なサポートを備えます。（もしもSILEが適切に処理出来ない言語やスクリプトがあれば知らせてください。対応します）

いくつかの言語では、同じ文字を使うが異なるように組まれるという状況が生じます。例えば、SindhiとUrduはアラビア文字\em{heh}を標準的なアラビア語とは異なるやり方で結合します。そのような場合は、あなたは\code{language}と\code{script}オプションを\command{\\font}コマンド中で適切に指定しなければなりません。

\bidi-on
\begin{verbatim}
\line
Standard Arabic
\\font[family=Scheherazade,language=ar,script=Arab]\{ه{}ه{}ه\};
Sindi:
\\font[family=Scheherazade,language=snd,script=Arab]\{ه{}ه{}ه\};
Urdu:
\\font[family=Scheherazade,language=urd,script=Arab]\{ه{}ه{}ه\}.
\line
\end{verbatim}

\begin{examplefont}
\line
Standard Arabic: \font[family=Scheherazade,language=ar,script=Arab]{ههه};
Sindi: \font[family=Scheherazade,language=snd,script=Arab]{ههه};
Urdu: \font[family=Scheherazade,language=urd,script=Arab]{ههه}.
\line
\end{examplefont}
\bidi-off

（\code{script}オプションの完全なリストについては\url{http://www.simon-cozens.org/content/duffers-guide-fontconfig-and-harfbuzz}を参照のこと）

\section{ファイルの取り込みとLuaコード}

長大な文書を作成するとき、あなたはSILE文書を複数のファイルに分割して管理したくなるでしょう。例えば、それぞれの章を別のファイルに小分けしたり、ユーザー定義のコマンドを開発し（第6章を参照）、それをひとまとめのファイルにして文書の本文とは分けて管理したり。その場合、異なるSILEファイルを取り込む必要があります。

その機能は\code{\\include}コマンドにより提供されます。これには、必須の\code{src=\em{<path>}}パラメータによりファイルへのパスを示す必要があります。 例えば、あなたは学位論文を次のように書きたくなるでしょう。

\begin{verbatim}
\line
\\begin[papersize=a4,class=thesis]\{document\}
\\include[src=macros]
\\include[src=chap1]
\\include[src=chap2]
\\include[src=chap3]
\dots\par
\\include[src=endmatter]
\\end\{document\}
\line
\end{verbatim}

\code{\\include}は入れ子になっても構いません。ファイルAがファイルBを取り込み、それがまたファイルCを取り込んだり。

SILEはLuaプログラム言語で書かれており、Luaインタプリタが実行時に利用可能です。ちょうどHTML文書中でJavascriptコードを\code{<script>}タグで実行するように、SILE文書中ではLuaコードを\code{\\script}コマンドを用いて実行可能です。（XML書式ではちょうどよく見えるでしょう）このコマンドはふたつの形態をとります。ひとつは\code{\\script[src=\em{<filename>}]}でLuaスクリプトをファイルごと取り込み、もうひとつは\code{\\script\{\dots\}}で、インラインのLuaコードです。

インラインで何か面白いことをやるにはSILEの内部に関する知識が必要です（幸運なことにコードはそれほど複雑ではない）が、とりあえず手始めに、Lua関数\code{SILE.typesetter:typeset(\dots)}を使ってみましょう。これはページにテキストを加えます。\code{SILE.call("\dots")}はSILEコマンドを呼び出し、\code{SILE.typesetter:leaveHmode()}は現在のパラグラフを終了し、テキストを出力します。 例として、

\begin{verbatim}
\line
\\begin\{script\}
  for i=1,10 do
    SILE.typesetter:typeset(i .. " x " .. i .. " = " .. i*i .. ". ")
    SILE.typesetter:leaveHmode()
    SILE.call("smallskip")
  end
\\end\{script\}
\line
\end{verbatim}

\noindent{}は以下を出力します。

\begin{examplefont}
\line
\begin{script}
  SILE.call("indent");SILE.typesetter:leaveHmode()
  for i=1,10 do
    SILE.typesetter:typeset(i .. " x " .. i .. " = " .. i*i .. ". ")
    SILE.typesetter:leaveHmode()
    SILE.call("smallskip")
  end
\end{script}
\line
\end{examplefont}
\chapter{SILEパッケージ}

SILEには付加的な機能を提供する様々なパッケージが付属しています。
事実、SILE の実際の「中核」（“core”）となる機能はかなりコンパクトで拡張性に富み、ほとんどの重要な機能はアドオンパッケージとして提供されています。SILEパッケージはLuaプログラミング言語で書かれており、新たなコマンドを定義したり、SILEの動作を変更したり、実際のところ、Luaでできることは何でもできます。

先に述べたとおり、パッケージのロードは\code{\\script}コマンドで行われ、これはLuaコードを実行します。規約として、パッケージはあなたの作業ディレクトリ、またはSILEのインストールディレクトリの、\code{packages/}サブディレクトリに入れることになります。例えば、すぐ後に述べる\code{grid}パッケージは通常は\code{/usr/local/lib/sile/packages/grid.lua}にあります。これをロードするには、

\begin{verbatim}
\line
\\script[src=packages/grid]
\line
\end{verbatim}

とします。

\note{\notehead{SILEのパス検索} SILEは様々なディレクトリを検索します。まずはカレントディレクトリ、次に、もし環境変数\code{SILE_PATH}が設定されていれば、SILEはそのディレクトリを、そして標準的なインストールディレクトリ、\code{/usr/lib/sile}や\code{/usr/local/lib/sile}。TeXとは異なり、SILEはサブディレクトリを再帰的に検索しません。このためもしあなたが、あなたのマクロやクラス、パッケージファイルなどをサブディレクトリに置いたら、あなたはその完全な相対パスを指定しなければなりません。}

\section{image}

テキスト以外にもSILEは画像を挿入することができます。

\code{image}パッケージをロードすることで、HTMLのそれと同様の、\code{\\img}コマンドが使えるようになります。\code{img}は次のふたつのパラメータを取ります。\code{src=\dots}は画像ファイルへのパスで、またオプションとして、\code{height=\dots} あるいは\code{width=\dots}パラメータを表示する画像のサイズとして指定します。もしもサイズが指定されなければ、画像はその「自然な」\footnote{訳注：原著は‘natural’です。どういう意味なのかよく分かりません。}ピクセルサイズで表示されます。

\begin{note}
デフォルトのlibtexpdfバックエンドでは、画像はJPEG、PNG、EPS、PDFフォーマットがサポートされます。Pango/CairoバックエンドではPNGのみです。
\end{note}

それでは200x243ピクセルの画像を、\code{\\img[src=documentation/gutenberg.png]}で表示させてみましょう。\par
\img[src=documentation/gutenberg.png]

\raggedright{
それと、（それぞれ）\code{\\img[src=documentation/gutenberg.png,width=120px]}、\goodbreak\code{\\img[src=documentation/gutenberg.png,height=200px]}、\goodbreak\code{\\img[src=documentation/gutenberg.png,width=120px,height=200px]}です。}

\img[src=documentation/gutenberg.png,width=120px]
\img[src=documentation/gutenberg.png,height=200px]
\img[src=documentation/gutenberg.png,width=120px,height=200px]


画像は、あたかも非常に大きな文字のように、テキストのベースラインに沿って配置されることに注意してください。

\section{rules}
\code{rules}パッケージは罫線を描画します。これはふたつのコマンドを提供します。

まずは\code{\\hrule}で、これは与えられた太さ（高さ）と長さ（幅）の線分を描画します。

罫線は他のテキストと全く同じように取り扱われます。このため、パラグラフの途中で、このように\hrule[width=20pt, height=0.5pt]描画することも可能です。（これは\code{\\hrule[width=20pt, height=0.5pt]}で生成されました)

画像と同じく、罫線はテキストのベースラインに沿って配置されます。

\code{rules}パッケージで提供される、ふたつ目のコマンドは\code{\\underline}で、これは下線を引くものです。

\note{「下線」は文書を作成する上で、あまり良い習慣とは言えません。\underline{決して}使わないでください。}

(これは\code{\\underline\{}決して\code{\}}で生成されました)

\section{color}


\code{color}パッケージは、テキストや罫線の色を一時的に変えるためのものです。 このパッケージはひとつのパラメータを取る、\code{\\color}コマンドを提供します。パラメータは\code{color=\em{<color \nobreak{}specification>}}で引数として与えられたテキストや罫線を、その色で描画します。色の指定法はHTMLと同じです。16進数値\code{x}を使ったRGB値で\code{#xxx}または\code{#xxxxxx}の形式（例えば、\code{#000}は黒で\code{#fff}は白、\code{#f00}は赤）、またはHTMLとCSSにおける名前付きの色指定が可能です。

\note{HTMLとCSSの名前付き色のリストは\code{http://dev.w3.org/csswg/css-color/#named-colors}にあります。}

例として挙げると、\color[color=red]{このテキストは\code{\\color[color=red]\{\dots\}}での出力です}。

罫線の例も挙げておきましょう。\code{\\color[color=#22dd33]}:
\color[color=#ffdd33]{\hrule[width=120pt,height=0.5pt]}

\section{rotate}
\code{rotate}パッケージは回転機能を提供します。これにより、\code{rotate=<angle>}をフレーム宣言に加えることで、フレーム全体を回転させることができます。また、\code{\\rotate[angle=<angle>]\{...\}}コマンドで、あらゆるものを回転させることができます。ここで\code{<angle>}は角度を「度」で表したものです。

回転される描画物はボックスの中に配置され、回転されます。その高さと幅は再度計算され、組版のための通常の水平リストに送られます。このため、回転される内容の周囲には余白が確保されます。このことを理解するために実例をいくつか示しましょう。 here is some text rotated by
\rotate[angle=10]{ten}, \rotate[angle=20]{twenty} and \rotate[angle=40]{forty} degrees.


前行は以下のコードで生成されました。

\begin{verbatim}
\line
here is some text rotated by
\\rotate[angle=10]\{ten\}, \\rotate[angle=20]\{twenty\} and \\rotate[angle=40]\{forty\} degrees.
\line
\end{verbatim}

\section{features}
Chapter 3で述べたように、SILEは自動的に、フォントで定義されたリガチャを適用します。これらのリガチャは、フォントファイルの\em{フィーチャ}\footnote{訳注：原文は単に features。OpenType などの高度な組版拡張機能のこと}テーブルで定義されています。リガチャ（複数のグリフがひとつのグリフとして表示される）の他にも、フィーチャテーブルでは様々なグリフ置換が定義されています。

\code{features}パッケージは、SILEがあなたが選択したフォントに対し、有効にするフィーチャを選択する機構を提供します。どのようなフィーチャが存在するかはフォントに依存します。いくつかのフォントでは、それがどのようなフィーチャをサポートしているのかを説明するマニュアルが付属しています。OpenType フィーチャに関する議論はこの文書の範疇を超えているのでここでは行いません。

フィーチャは、\code{\\font}コマンドのオプションで、「そのままの」フィーチャ名を渡すことで有効・無効にできます。

\begin{verbatim}
\line
\\font[features="+dlig,+hlig"]{...} \% turn on discretionary and historic ligatures
\line
\end{verbatim}

しかしながら、この方法は扱いづらく、フィーチャコードを覚えておく必要が出てきます。\code{features}はふたつのコマンドを提供します。\code{\\add-font-feature}と\code{\\remove-font-feature}で、OpenTypeフィーチャへのより簡単なアクセスを実現します。インターフェイスはTeXのパッケージの\code{fontspec}に由来しています。サポートされているOpenTypeフィーチャの完全な解説については、\code{fontspec}パッケージの文書を参照してください。\footnote{\code{http://texdoc.net/texmf-dist/doc/latex/fontspec/fontspec.pdf}}

以下に\code{features}パッケージで任意の（discretionary）リガチャと歴史的（historic）リガチャを制御する例を示します。

\begin{verbatim}
\line
\\add-font-feature[Ligatures=Rare]\\add-font-feature[Ligatures=Discretionary]
...
\\remove-font-feature[Ligatures=Rare]\\remove-font-feature[Ligatures=Discretionary]
\line
\end{verbatim}

\section{unichar}
SILEはUnicode対応であり、その入力はUTF-8エンコーディングです。（サポートされるUnicodeの範囲に関しては、使用するフォントに依存します）Unicodeで定義されたいくつかの文字はキーボードから直接入力するのは困難です。このため、\code{unichar}パッケージはこの問題に対処するための方法、Unicode コードを直接指定するコマンド、を提供します。\code{unichar}をロードすると、\code{\\unichar}コマンドが利用可能となります。

%%WINDOWS SPECIFIC
\begin{verbatim}
\line
\\unichar\{U+263A\} \% produces \font[family=Consolas]{\unichar{U+263A}}
\line
\end{verbatim}

\code{\\unichar}の引数が\code{U+}、\code{u+}、\code{0x}あるいは\code{0X}で始まる場合は、それは16進数値だとみなされます。そうでなければ10進数であると仮定されます。

\section{bidi}
ラテン文字などの用字系では文章は左から右へ（LTR）進みます。しかしながら、いくつかの用字系、特にアラビア語やヘブライ語では、右から左に（RTL）進みます。\code{bidi}パッケージ、これはデフォルトでロードされます、は右から左へ書き進める場合の文書や、LTRとRTLを混在させるような文書を、正しく組むための機能を提供します。これはデフォルトで読み込まれるため、パラグラフ中でLTRとRTLテキストの両方を書くことができ、SILEは正しい順序でそれらの文字が出力されることを保証します。

\code{bidi}パッケージはふたつのコマンド、\command{\\thisframeLTR}と\command{\\thisframeRTL}、これらは現在のフレームのデフォルトの書字方向を設定する、を提供します。すなわち、もしあなたがSILEにフレームがRTLであると指示するならば、文章は右端から始まり、左に進みます。このパッケージはまた、\command{\\bidi-off}と\command{\\bidi-on}コマンドを提供します。bidirectionalサポートを無効にすることで、もしかしたら処理速度を向上させることができるかもしれません。

\section{raiselower}

もしあなたが、画像や罫線、テキストなどがベースライン上に沿って配置させてくないならば、\code{raiselower}パッケージを使ってそれらを上げ下げすることができます。（\code{footnote}パッケージは脚注の参照番号を、上付き数字として表示するため、このパッケージを利用しています。）

これはふたつの単純なコマンドを提供します。\code{\\raise}と\code{\\lower}で、どちらも\code{height=\em{<dimension>}}をパラメータとして取ります。それぞれ引数となるものを、与えられた量だけ持ち上げたり、下げたりします。これらは行の高さや深さに影響しません。

Here is some text raised by \raise[height=3pt]{three points}; here is
some text lowered by \lower[height=4pt]{four points}.

前のパラグラフは以下のコードで生成されます。

\begin{verbatim}
Here is some text raised by \\raise[height=3pt]\{three points\}; here is
some text lowered by \\lower[height=4pt]\{four points\}.
\end{verbatim}

\section{grid}
\grid[spacing=15pt]
SILE は通常、以下に示すふたつのルールに従って行と行の間のスペースを決めます。

\noindent• SILEはベースライン間が、\code{baselineskip}と呼ばれるある固定された距離となるように、連続したふたつの行の間にスペースの挿入を試みる。

\noindent• もしも最初のルールによる結果によって、行間の距離が2ポイント以下になるならば、それを2ポイントとなるように強制する。（この量は\code{lineskip}の設定で調整可能)

2番目のルールは、前の行が大きなディセンダー（例えば、g、q、j、pなどの文字が含まれる）場合に、高いアセンダーを持つ（k、l、と大文字など）次の行とぶつかるのを防ぐためにあります。

これに加えて、\code{baselineskip}はある量の「伸張性」（‘stretch’）を持ちます。これはページ分割処理を最適化させるために役に立つ場合に、行間を広げたり、同様にパラグラフ間の距離を伸縮させたりします。

これらのルールの組み合わせにより、行はページの様々な位置で開始することになるのです。

これとは別の組版の流儀では、行は規則正しいグリッド上の決まった位置で始まることを要求します。いくらかの人々はグリッド上の組版によって生じる、ページの「カラー」（‘color’）を好みます。そしてこの手法は、しばしば非常に薄い紙に印字するときに、インクが裏から滲まないように工夫する目的として、行の位置をきっちり揃えるために用いられます。次の例を比べてみてください。左のものは行が紙の両面で同じ位置にくるようにしたもので、右はそのようになっていないものです。

\img[src=documentation/grid-1.png,height=130]
\img[src=documentation/grid-2.png,height=130]

\code{grid}パッケージはSILEの組版エンジンが、上記ふたつのルールを適用しないように動作を変更させます。その結果、行は常にグリッド上に整列され、パラグラフ間のスペースなどは常に、グリッド上に行が規則正しく並ぶように調整されます。パッケージをロードすることで、ふたつの新たなSILEコマンドが追加されます。\code{\\grid[spacing=\em{<dimension>}]}と\code{\\no-grid}です。最初のものはグリッド上の組版を、それが実行された時点以降から、有効にして、次のものはそれを無効にします。

このセクションのはじめで、\code{\\grid[spacing=15pt]}によって、15ポイントのグリッドが設定されています。グリッドが有効になったときの例文を示しましょう。

\smallskip
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
\smallskip

そして以下は、\code{\\no-grid}にした後のものです。

\no-grid\smallskip
Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam,
quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo
consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non
proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

\section{verbatim}
\code{verbatim}パッケージはプログラムのコードを引用したりするなど、フォーマッティングが重要な文章を表示したりする際に役に立ちます。これはSILEの設定を、左揃え、ハイフネーションなし、インデントなしの規則的なスペーシングとなるようにします。これはまた、SILEにスペースの数を勝手に減らしたりしないように伝え、また等幅フォントを使うように設定します。

\note{この名前にも関わらず、\code{verbatim}はSILEが特殊文字を扱うやり方を変えません。あなたは\code{verbatim}中でもバックスラッシュと波括弧をエスケープする必要があります。例えば、\code{\\\\}のように。}

それではverbatim環境の例を示してみましょう。

\begin{verbatim}
function SILE.repl()
  if not SILE._repl then SILE.initRepl() end
  SILE._repl:run()
end
\end{verbatim}

verbatim環境の中で使用するフォントを指定したければ、\code{verbatim:font}コマンドで再定義することができます。この文書では、

%%WINDOWS SPECIFIC
\begin{verbatim}
<define command="verbatim:font">
   <font family="Consolas" size="10pt"/>
</define>
\end{verbatim}

\noindent{}です。

\section{他のパッケージにより利用されるパッケージ}

これらに加えて、\em{おそらく}あなたが直接は利用しないであろうパッケージもあります。それらのパッケージは、他のパッケージやクラスにより基本的な機能を提供するという目的のために存在します。例えば\code{book}クラスは、他の補助的なパッケージからの機能で構成されています。

\subsection{footnotes}

例えば、\code{book}クラスでは、\code{\\footnote}コマンドで脚注を加えることができることをみました。このコマンドは実際には、\code{footnotes}パッケージにより提供されています。\code{book}クラスはこのパッケージをロードし、どこに脚注を置くべきか伝え、そして\code{footnotes}パッケージは脚注を整形し表示させます。これは他にも、以下に述べる数々のパッケージを利用しながら行われます。

\subsection{counters}

SILEの様々な部分、例えば\code{footnotes}パッケージや章・節用のコマンド、はカウンタを利用します。現在の脚注番号、章番号、などに使うためです。\code{counters}パッケージは、カウンタを設定し、カウンタを増加させ、表示させたりすることに使えます。これは以下のようなコマンドを提供します。

• \code{\\set-counter[id=\em{<counter-name>},value=\em{<value>}]} — \code{<counter-name>}という名前のカウンタを与えられた値で設定します。

• \code{\\increment-counter[id=\em{<counter-name>}]} — \code{\\set-counter} と同様に、しかし\code{value}パラメータがなければ、カウンタを1だけ増加させます。

• \code{\\show-counter[id=\em{<counter-name>}]} — これはカウンタの値を、宣言された表示形式で整形し、表示します。

\note{カウンタパッケージのすべてのコマンドはオプションとして、\code{display=\em{<display-type>}}パラメータをとり、これはカウンタの\em{表示形式}を設定します。

可能な表示形式は、デフォルトで\code{arabic}、アルファベットのカウンタとして\code{alpha}、小文字のローマ数字\code{roman}、そして大文字のローマ数字\code{Roman}です。}

例えば、次のようなSILEコードは、

\begin{verbatim}
\line
\\set-counter[id=mycounter, value=2]
\\show-counter[id=mycounter]

\\increment-counter[id=mycounter]
\\show-counter[id=mycounter, display=roman]
\line
\end{verbatim}

以下のようになります。

\line
\examplefont{2

\noindent{}iii}
\line

\subsection{pdf}
\code{pdf}パッケージは（基本的な）PDFリンクや目次の機能を実現します。これは3つのコマンドを提供します。\command{\\pdf:destination}、\command{\\pdf:link}、そして\command{\\pdf:bookmark}です。

コマンド\command{\\pdf:destination}はリンク先（ターゲット）を生成します。これはパラメータとして\code{name}をとり、リンク先を特定するための一意的な名前を指定します。文書中のある場所にリンクを張るには、\code{\\pdf:link[dest=\goodbreak{}name]\{}内容\code{\}}を使います。

もし、\code{pdf}パッケージが\code{tableofcontents}パッケージのあとにロードされたら（例えば、\code{book}クラスを用いた文書の中）、PDF文書はしおり（アウトライン）付のものとなります。

\subsection{frametricks}

最初の章で述べたように、SILEはページのどの部分にテキストを置くか指定するために、フレームを用います。\code{frametricks}パッケージはパッケージの著者に、フレームを扱うための数々のコマンドを提供します。

とにかく有用なのは\code{showframe}です。これは出力エンジンに、フレームを線で囲いラベルを付けるように指示します。これはオプションでパラメータ\code{id=\em{<frame id>}}をとります。もしこのオプションが与えられなければ、現在のフレームが使用されます。もしIDが\code{all}であれば、現在のクラスの中で宣言されたすべてのフレームが表示されます。

\breakframevertical\par
コマンド\code{\\breakframevertical}は現在のフレームを、与えられた地点で上下2分割にします。現在のフレームがID \code{main}を持つとしましょう。フレームが分割されると、\code{main}は上のフレーム（コマンド挿入以前）となり、下のフレーム（コマンド挿入以降）は\code{main_}というIDとなります。このパラグラフの先頭では、\code{\\breakframevertical}コマンドを実行しています。そしてここで、コマンド\code{\\showframe}を実行してみましょう。\showframe{}見てわかる通り、現在のフレームは\code{\script{SILE.typesetter:typeset(SILE.typesetter.frame.id)}}
で、ちょうどこのパラグラフの開始位置で始まります。

同様に、\code{\\breakframehorizontal}コマンドは、フレームを左右に分割します。このコマンドは必須でない引数として、\code{offset=<dimension>}をとり、これはどの位置でフレームを分割するかを指定します。もしこれが与えられなければ、フレームはその行の現在地で分割されます。

コマンド\code{\\shiftframeedge}は、現在のフレームを左右に再配置します。これは\code{left=}と（または）\code{right=}パラメータをとり、パラメータの値は正か負の長さです。このコマンドはフレームの先頭で使用されなければなりません。それはこのコマンドが組版エンジンを再初期化するからです。

\float[bottomboundary=5pt]{\font[size=50pt]{こ}}れらをすべて組み合わせた\code{\\float}コマンドは、現在のフレームを分割し、フロートオブジェクトを保持する小さなフレーム（この文章のはじめのドロップキャップのように）を生成し、文章を周囲のフレームに流し込み、文章がフロートオブジェクトの脇を過ぎ去れば、フレームを元のように戻します。\code{\\float}コマンドは必須でないふたつのパラメータを取ります。\code{bottomboundary=\em{<dimension>}}と\code{rightboundary=\em{<dimension>}}で、フレームの周りに余白を付与します。このパラグラフのはじめでは、コマンド\code{\\float[bottomboundary=5pt]\{\\font[size=50pt]\{}こ\code{\}\}}が実行されています。

最後に、本文とは分離された、サイドバーのようなフレームを定義する方法を示しましょう。後の章でどのようにしてそれが実現されるか見るでしょう。\footnote{訳注：原文はWe’ll see how to do that in a later chapter, but
this raises the obvious question: if they’re not part of the text flow, how do we
get stuff into them?} \code{frametricks}は\command{\\typeset-into}コマンドを提供します。これはテキストを指定されたフレームに描画します。

\begin{verbatim}
\line
\\typeset-into[frame=sidebar]\{ ... frame content here ... \}
\line
\end{verbatim}

\subsection{insertions}

\code{footnotes}パッケージは、補助的なもの（すなわち脚注の内容）を内容として受け取り、フレームを適当なサイズに縮小して脚注フレームに挿入します。このような作業は\code{insertions}パッケージの力で実現されています。これはユーザの目に見えるSILEコマンドを提供しませんが、他のパッケージにLua機能を提供します。TeXnician たちは、これがSILEのコアではなく、外部のアドオンパッケージとして実装されていることに興味を持つかもしれません。

\subsection{twoside}

Chapter 4で述べた\code{book}クラスは左右の対となるページマスタ\footnote{訳注：適切な訳がわかりません。}を設定します。\code{twoside}パッケージはヘッダやその他の位置の入れ替えなどを行います。これは一般ユーザからは利用されません。

\subsection{masters}

ページマスタ設定機能もそれ自身、アドオンパッケージのひとつです。それはクラス中で、フレームのセットを定義し、一時的あるいは恒久的にそれらの間を切り替えることを可能にします。これはコマンド\command{\\define-master-template}（これは Chapter 8 で見る\command{\\pagetemplate}をまねたもの）、\command{\\switch-master}、そして\command{\\switch-master-one-page}を定義します。このパッケージについて、より詳しくは、\code{tests/masters.sil}を参照してください。

%%FIXME
\note{\notehead{訳注：原文（よく意味が分かりません）}
The masters functionality is also itself an add-on package. It allows a class to
define sets of frames and switch between them either temporarily or permanently.
It defines the commands \command{\\define-master-template} (which is pattern
on the \command{\\pagetemplate} function we will meet in chapter 8), \command{\\switch-master}
and \command{\\switch-master-one-page}. See \code{tests/masters.sil} for more
about this package.}

\subsection{infonode}

\note{このパッケージはクラスを設計する人にのみ有用です。}

文書を処理するとき、SILEはまずパラグラフを行に分割します。それから行をページ内に配置し、最終的にページを出力します。すなわち、SILEがパラグラフ中のテキストを処理している間では、そのテキストがどのページに現れるかは明らかではないのです。これはインデックスや目次などを生成する際に困難をもたらします。なぜならそれらは、ある特定のテキストなどの要素が現れるページ番号を必要とするからです。

この問題に対処するため、\code{infonode}は、あなたが入力テキスト・ストリーム中に\em{情報ノード}を挿入することを可能にします。ページが出力されるとき、これらのノードはあるリストに集約され、クラスの出力ルーチンは、どのノードが特定のページに出現するか決定するために、このリストを調べることができます。\code{infonode}は\code{\\info}コマンドコマンドを提供します。これはテキスト・ストリームに情報ノードを挿入するためのもので、ふたつのパラメータを取ります。\code{category=}と\code{value=}です。カテゴリは似たような種類のノードをグループ化するのに使用されます。

例として、聖書を考えましょう。どの範囲の節がページに含まれるかヘッダに出力たいとします。このとき、新たな節を開始するコマンドで、情報ノードを節への参照とともに挿入します。

\begin{verbatim}
\line
SILE.Commands["info"]({ category = "references", value = ref }, {})
\line
\end{verbatim}

各ページの最後に呼ばれる\code{endPage}メソッドで、“references”情報ノードのリストを調べます。

\begin{verbatim}
\line
local refs = SILE.scratch.info.thispage.references
local runningHead = SILE.shaper.shape(refs[1] .. " - " .. refs[#refs])
SILE.typesetNaturally(rhFrame, runningHead);
\line
\end{verbatim}

\subsection{inputfilter}
\code{inputfilter}パッケージは、クラスの製作者に、SILEによって処理される前の入力データに、フィルタをかける方法を提供します。これは文書を表す抽象構文木（abstract syntax tree）を書き換えることで可能となります。

\code{inputfilter}を、あなたのクラスで\code{class:loadPackage("inputfilter")}によりロードすることで、ふたつの新たなLua関数が利用可能となります。\code{transformContent}と\code{createCommand}です。\code{transformContent}は文書の内容を構成する木構造（content tree）に対し、その内容となるテキストに変換関数を適用します。簡単な例として、\code{examples/inputfilter.sil}を、より完全なものとして、\code{packages/chordmode.sil}を見てください。

\chapter{SILEマクロとコマンド}

\noindent 我々がコンピュータを利用する理由のひとつは、それが反復作業を得意とすることでしょう。おそらくコンピューターを利用するなかで最も重要な技術は、特にプログラミングにおいて、繰り返しなされる部分を見極め、人間の代わりにコンピュータにそれをやらせることです。すなわち、Don‘t Repeat Yourself。

SILEにおいてもこれは同じことです。しばらくSILEを使っていれば、入力にはパターンがあり、何度も繰り返しなされることがあるということに気づくでしょう。

\section{単純なマクロ}

\define[command=SILE]{S\lower[height=0.5ex]{I}L\glue[width=-.2em]\raise[height=0.6ex]{\font[size=0.8em]{E}}}
仮にSILEのちょっとした「でこぼこ道」ロゴをデザインしたいとしましょう。（ T\glue[width=-.1667em]\lower[height=0.5ex]{E}\glue[width=-.125em]Xの熱烈なファンにはおなじみの）我々のロゴは「\SILE」です。あまり素晴らしいものとは言えませんが、この節ではこのロゴを例題として用いましょう。

このロゴを出力するには、我々は\SILEに、‘S’を、少し下げて（ちょうどexの半分）‘I’を、続けて‘L’を、ちょっと戻って少し小さな‘E’をやや持ちあげて、出力するように指示します。

\SILEコードではこれは、

\begin{verbatim}
\line
S\\lower[height=0.5ex]\{I\}L\\glue[width=-.2em]\\raise[height=0.6ex]\{\\font[size=0.8em]\{E\}\}
\line
\end{verbatim}

（\code{\\glue}コマンドについては気にしないでください。後で説明します）

もう既に4回も、この章ではこのロゴを入力しています。何度もこのコードを繰り返し入力したくはないですね。我々がすべきことは、コンピュータに、「これは\SILEのロゴ。\code{\\SILE}を入力したら、\code{S\\lower[height=0.5ex]\{I\}L\\glue[width=-.2em]\\raise[height=0.6ex]\{\\font[size=0.8em]\{E\}\}}と解釈せよ」と指示することです。

つまり、コマンドを定義するのです。

SILE\footnote{ロゴを使うのはもう辞めましょう。}では、コマンドを定義するふたつの方法があります。最も単純なコマンドは、例として挙げたような\code{\\SILE}コマンドで、「\code{\\x}と書いたら、かわりに\code{X \\Y Z}で置き換える」というものです。これらは\em{マクロ}と呼ばれ、置き換えの作業を\em{マクロ展開}と呼びます。

あなたはこの種のマクロを、SILEファイルの中で定義することができます。ちょうどここでは、

\begin{verbatim}
\line
\\define[command=SILE]\{
S\\lower[height=0.5ex]\{I\}L\\glue[width=-.2em]\goodbreak\\raise[height=0.6ex]\{\\font[size=0.8em]\{E\}\}
\}
\line
\end{verbatim}

\noindent{}としました。

ここでは、ビルトインのSILEコマンド\code{\\define}を使用しています。\code{\\define}はオプションとして\code{command}を取り、その値は定義するコマンドの名前です。\code{\\define}コマンドの内容は、コマンドが使用される時に実行されるべきSILEインストラクションです。

\begin{note}
ここで、SILEコマンドで利用可能な名前について知っておくべきでしょう。

XML風書式の入力ファイルでは、コマンド名はXMLタグ名として許されるものでなければなりません。TeX風書式ではアルファベットとアラビア数字、ハイフンとコロンが使用可能です。これに加えて、任意の1文字コマンド名が利用可能です。（つまり、バックスラッシュを書くのに\code{\\\\}が使えます）

コマンドを定義する際に、XML風書式でそれを行うと、どんなコマンド名でも可能です—例えそれがXML風書式の入力ファイルで利用不可であっても！（XML風書式のSILEファイルで奇妙な名前のコマンドを定義し、TeX風書式でそれをつかうことはできます）TeX風書式では、それはパラメータ値として有効なものでなければなりません。パラメータ値はコンマ、セミコロン、あるいは閉じ括弧まで続いてしまうかもしれません。
\end{note}

\section{内容を伴うマクロ}

それでは次の段階に進みましょう。コマンドを定義していく中で、時々、単純な置き換え以上の、引数を伴うものが必要となることがあります。例として、\code{color}パッケージを考えましょう。我々はテキストを\color[color=red]{このように}赤色で描画したいとします。通常のやり方では、これは、

%%WINDOWS SPECIFIC
\begin{verbatim}
\line
\\color[color=red]\{\font[family=Yu Mincho]{このように}\}
\line
\end{verbatim}

\noindent{}のようになります。

しかしながら、我々は常に「このように」という語をハイライトしたいわけではありません。別のテキストをハイライトしたい場合もあります。そこで我々は、ある与えられたものを、コマンド\code{\\color\break{}[color=red]\{ ... \}}で囲む必要が出てきます。 つまり、引数を取るコマンドを定義したいのです。

これをSILEで行うには、\code{\\process}コマンドを使います。 \code{\\process}は\code{\\define}中でのみ有効です。（その他の場所で使おうとするとぐちゃぐちゃな結果となるでしょう）これは、「このコマンドの引数として与えられたものを何でも実行せよ」という意味です。すなわち、赤でなにか描画するコマンドを定義するには、

\begin{verbatim}
\line
\\define[command=red]\{\\color[color=red]\{\\process\}\}

…

Making things red is a \\red\{silly\} way to emphasise text.
\line
\end{verbatim}

\begin{note}
\code{\\process}コマンドはひとつのマクロ中で何度も呼ぶことはできません。

%例えば\code{\\chapter}コマンドの定義では、⑴章の見出しを大きな太字で描画する、⑵章の見出しを左ページのヘッダとして使う、という処理が入ります。もしあなたが、\code{\\chapter}コマンドを自身で定義しようとするならば、困ったことにまります。章の見出しを太字で描画するために\code{\\process}を使ってしまったら、ヘッダでそれを使えなくなってしまうのです。

このため、\code{\\chapter}コマンドは単純なマクロとしては実装できません。コマンドを定義する別の方法は、Luaプログラミング言語を使ってそれを書くことです。そしてそれは実際に\code{\\chapter}コマンドの定義で行われています。後の章でどのようにそれを行うか見るでしょう。.

\code{\\define}コマンドは、本当に単純なことをやるためだけのものです。
\end{note}

\section{ネストしたマクロ}

マクロの中でマクロを呼び出すことができます。マクロは単に現在処理中のステップにおける置き換えでしかありません。SILEがマクロコマンドを読み込むとき、SILEはあたかもあなたがマクロの定義内容を入力していたかのように振舞います。もちろん、そのようなマクロ定義は他のコマンドを含むかもしれません。

このため、ごく単純なマクロの処理で、実に様々な自動化を行うことができます。

例えば、この文書ではたくさんのノートがあります。そこではパラグラフは、イタリック体\footnote{訳注：和訳ではイタリックではありません。}で、左マージン付きでふたつの太い線の間に囲まれて表示されます。これは\code{\\note}コマンドによって実現されています。このコマンドはビルトイン・コマンドではなく、この文書で読み込まれている、\code{documentation/macros.sil}ファイル中で定義されています。その定義は、XML風書式で、

\begin{verbatim}
\line
<define command="line">
  <par/><smallskip/><noindent/>
  <hrule width="450pt" height="0.3pt"/><par/>
  <novbreak/><smallskip/><novbreak/>
</define>

<define command="narrower">
  <set parameter="document.lskip" value="24pt"/>
  <process>
  <set parameter="document.lskip" value="0pt"/>
</end>

<define command="notefont"><font style="italic" size="10pt"><process/></font></notefont>

<define command="note">
  <narrower>
    <line/>
    <notefont><process/></notefont>
    <line/>
  </narrower>
</define>
\line
\end{verbatim}

ここで初めて登場するコマンドは\code{\\set}です。これについてはすぐに議論します。

\chapter{SILEの設定}

コマンドの他にも、SILEはその動作に影響を与える様々な仕組みを提供します。SILEのパラメータを操作することで、その出力結果に対し、些細なものから劇的なものまで、実に様々な変化を与えることができます。外部パッケージはそれ自身の設定を宣言することができます（SILEに同梱されているパッケージはそうではありませんが）が、ここではSILE本体に組み込みの設定のみ解説することにしましょう。

SILEの設定は\em{名前空間}を持ちます。これは、⑴その設定がシステムのどのエリアに影響するのか、その名前から明らかなようにする、⑵各パッケージが、他のパッケージやSILE内部に干渉する心配なしに設定を行えるようにする、ために必要なことです。それぞれの設定パラメータは\code{\em{area.name}}の形をとります—例えば\code{typesetter.orphanpenalty}は、タイプセッタがオーファン\footnote{訳注：パラグラフの最終行が、ごく少数の語句のみから構成されてしまい、それが最終行に「取り残された」ようになること。または、パラグラフの先頭行のみが、前のページに分離して取り残されることを指す。}に対するペナルティを課す際の設定です。

SILE文書中から設定を変更するインターフェイスは、\code{\\set}コマンドです。これはふたつのオプションを取ります。どの設定が変更されるのかを表す\em{パラメータ}と、それがどのように変更されるのかを示す\em{値}です。例えば、

\begin{verbatim}
\line
\\set[parameter=typesetter.orphanpenalty, value=250]
\line
\end{verbatim}

もし、\code{\\set}コマンドが引数とともに与えられるならば、それは引数として与えられたブロックのみの、局所的な変更であるとみなされます。言うならば、

\begin{verbatim}
\line
\\set[parameter=typesetter.orphanpenalty, value=250]\{ \\lorem \}
\line
\end{verbatim}

\noindent{}はオーファン・ペナルティを250に設定し、\code{\\lorem}コマンドで与えられる50語からなるダミーのテキストを組み、オーファン・ペナルティを元の値に戻します。

それでは各ビルトインの設定がどのようなものなのか見てみましょう。まずはより明瞭なものから始め、次第に理解が難しいものへ移ります。

\section{スペーシング設定}

\code{\\note}環境の\code{document.lskip}パラメータを例にとりましょう。これは\em{グルー}パラメータで、各行の左側に与えられるスペースです。この値を正の値に設定することで、左マージンを実効的に増加させることができます。同様に、\code{document.rskip}は各行の右側にスペースを与えます。

\begin{note}
\notehead{グルー} \em{グルー}パラメータは、通常の長さとは若干異なります。グルーは基本的には「スペース」で、長さとして表されますが、ふたつの付加的な構成要素を持ちます。\em{ストレッチ}と\em{スキップ}\footnote{訳注：シュリンクの間違いではないかと思われます。}で、\code{<dimension> plus <dimension> minus <dimension>}の形で指定されます。最初の長さ（dimension）は基本となる長さで、ストレッチはそれに加えることができる最大の長さ、シュリンクは逆に差し引くことができる長さです。例えば、\code{12pt plus 6pt minus 3pt}は理想的には12ポイントだが、最大で18ポイント、最小で9ポイントまで伸び縮みが許容されます。
\end{note}

ここで、\code{center}環境がどのように実装されているか考えましょう。まずは我々は非常に柔軟に伸びるグルーを左右のマージンに追加します。

\begin{verbatim}
\line
\\set[parameter=document.lskip,value=0pt plus 100000pt]
\\set[parameter=document.rskip,value=0pt plus 100000pt]
\line
\end{verbatim}

これは以下のような結果を出力します。

\medskip%
\begin{examplefont}%
\set[parameter=document.lskip,value=0pt plus 500pt]% Lying for didactic purposes
\set[parameter=document.rskip,value=0pt plus 500pt]
\set[parameter=document.spaceskip,value=0.5en plus 120pt minus 0.3en]

Here is some text which is almost centered. However, there are three problems:
first, the normal paragraph indentation is applied, meaning the first line of
text is indented.
Second, the space between words is stretchable, meaning that the lines are
stretched out so they almost seem justified.
Finally, by default SILE adds very large glue at the
end of each paragraph so that when the text is justified, the spacing of the
last line is not stretched out of proportion. This makes the centering of the
last line look a bit odd. We will deal with these three issues in the following
paragraphs.\par
\end{examplefont}
\medskip

\begin{note}
\notehead{訳}
この文章はほぼ中央寄せとなっています。しかしながら、これには3つの問題があります。まずは、通常のパラグラフのように、最初の行にはインデントが付加されています。次に単語間のスペースが伸張可能となっているため、各行はほぼ行端揃えされたように見えてしまいます。最後に、デフォルトでは、SILEはパラグラフの終わりに非常に大きなグルーを挿入します。これはテキストが行端揃えの場合に、最後の行が行長に合わせて伸張されてしまうのを避けるためです。このため最後の行は、中央寄せとしてはやや不自然に見えてしまいます。この3つの点について、続けてその対処法について見てみましょう。
\end{note}

\set[parameter=document.lskip,value=0pt]%
\set[parameter=document.rskip,value=0pt]%
\set[parameter=document.spaceskip]%
各パラグラフの最初のインデント量は、\code{document.parindent}で制御されます。これはグルーパラメータで、デフォルトでは20ポイントで、伸び縮みしません。実際には、パラグラフのはじめに挿入される空白の量は\code{current.parindent}です。各パラグラフの出力後に、
\code{current.parident}は、\code{document.parindent}の値でリセットされます。\code{\\noindent}コマンドは\code{current.parindent}をゼロに設定することで実現されます。

\medskip%
\set[parameter=current.parindent,value=-20pt]%
\set[parameter=document.lskip,value=20pt]%
さて、このように「ぶら下げ」インデントにするのはどうすればよいでしょう。ここでは、\code{document.lskip}を20ポイントに、\code{current.parindent}を\em{マイナス}20ポイントに設定しています。 （つまり、\allowbreak\code{\\set[parameter=document.lskip,value=20pt]}\goodbreakと\goodbreak\code{\\set[parameter=current.parindent,\break{}value=-20pt]}\goodbreak{}を実行します）

\medskip%
\set[parameter=document.lskip,value=0pt]%
\em{パラグラフ}間のスペースはグルーパラメータ\code{document.parskip}で設定されます。これは通常は、1ポイントのストレッチを持つ、5ポイントのグルーとして設定されます。

グリッド上の組版の節で述べたように、パラグラフ内の\em{行}間のスペースはふたつのルールにより決定されます。ここでは、それを設定パラメータを用いて再び説明してみましょう。

\noindent• SILEはふたつの連続した行の間の距離が、ちょうど\code{document.baselineskip}となるように試みます。

\noindent• もし最初のルールを適用した結果として、パラグラフの最後の行と次のパラグラフの最初の行の間の距離が、\code{document.lineskip}以下となるようであれば、それが\code{document.lineskip}だけ確保されるように調整します。

最後のスペーシング設定は、\code{document.spaceskip}です。通常、\em{単語}間のスペースは、現在のフォントの空白文字の幅より決定されますが、行端揃えを実現するために、このスペースは伸縮可能となります。具体的には、もし仮に現在のフォントでのスペース幅が、\code{<space>}だとすると、\code{document.spaceskip}のデフォルト値は、\code{1.2 <space> plus 0.5 <space> minus 0.333 <space>}と設定されます。\footnote{この幾分適当な値の設定はバグとも言えるでしょう。}

これを陽に設定したければ、\code{document.spaceskip}により設定を行います。もしもデフォルト値に戻したければ（つまりフォントの空白文字の幅を計り直す）、設定を\em{クリア}する必要があます。これを行うには、\code{\\set}コマンドを\code{value}パラメータなしで呼び出します。\code{\\set[parameter=document.spaceskip]}のようにです。

\section{タイプセッタ設定}

SILEのスペーシングを制御する設定は、生成される文書に対して明白な影響を与えます。タイプセッタにも操作するスイッチがあります。

\code{typesetter.widowpenalty}と\code{typesetter.orphanpenalty}\footnote{TeX
ユーザはリネームされていることに注意}は、SILEがどの程度、ページの始まりや終わりにはぐれた行があるのを抑止するかを決定します。\em{ウィドウ}は改ページの際に、1行だけ前のページの終わりに取り残されることを、\em{オーフォン}はパラグラフの最後の行だけが次のページに引き離されてしまうことを指します。デフォルトでは、これらに対し、150ポイントの\em{penalty}が与えられています。この値は\code{10000}までの値を取り、最大値は「ウィドウとオーファンの禁止」を意味します。

\set[parameter=typesetter.parfillskip,value=0pt]
SILEは非常によく伸張するグルーを、各パラグラフの末尾に自動的に挿入します。これなくしては、行端揃えのアルゴリズムが最終行を含むパラグラフ全体に渡って適用され、パラグラフのすべての行が両端揃えとなってしまいます。（通常、我々は最後の行は左揃えにします）このグルーの量は\code{typesetter.parfillskip}により設定されています。デフォルト値は\code{0pt plus 10000pt}ですが、このパラグラフではゼロにしてあります。

それでは、ようやく中央寄せの実装を完結させましょう。\hss

\begin{verbatim}
\line
\\set[parameter=document.lskip,value=0pt plus 100000pt]
\\set[parameter=document.rskip,value=0pt plus 100000pt]
\\set[parameter=document.spaceskip,value=0.5en]
\\set[parameter=current.parindent,value=0pt]
\\set[parameter=document.parindent,value=0pt]
\\set[parameter=typesetter.parfillskip,value=0pt]
\line
\end{verbatim}

\medskip
\noindent\begin{examplefont}%
\set[parameter=document.lskip,value=0pt plus 100000pt]%
\set[parameter=document.rskip,value=0pt plus 100000pt]%
\set[parameter=document.spaceskip,value=0.5en]%
\set[parameter=current.parindent,value=0pt]%
\set[parameter=typesetter.parfillskip,value=0pt]

And this is (more or less) how the \code{center} environment is defined in
the plain class: we make the margins able to expand but the spaces not able
to expand; we turn off indenting at the started of the paragraph, and we turn
off the filling glue at the end of the paragraph.
\par
\end{examplefont}

\set[parameter=typesetter.parfillskip,value=0pt plus 10000pt]
\begin{note}
\notehead{訳}
そしてこれがほぼ、plainクラスで定義されている\code{center}環境そのものです。マージンは伸張可能ですが、スペースは伸張せず、パラグラフの最初のインデントやパラグラフの最後のグルーは無効化されています。
\end{note}
\medskip

\set[parameter=typesetter.parfillskip,value=0pt plus 10000pt]
最後に、タイプセッタは入力におけるパラグラフ分割方法を知る必要があります。これは通常、ふたつの連続した改行文字です。しかしながら、XML入力を扱う際には、この仮定は適切ではありません。このような場合は、\code{typesetter.parseppattern}をLuaパターンを使って指定することができます。これはデフォルトでは\code{\\n\\n+}です。これに加えて、入力における複数のスペースがひとつのスペースに変換されるやり方を定義するのが \code{shaper.spacepattern}の設定です。これは\code{\%s+}をデフォルト値として持ちます。（任意の数のスペースがひとつのスペースとみなされる）もしあなたが、スペースの数をそのまま保ちたいならば、スペースパターンを\code{\%s}に設定するとよいでしょう。

\section{ラインブレーキング設定}

SILEのラインブレーキング（行分割）アルゴリズムはTeXからの借り物であり、そして同等の水準のカスタマイズ性を備えます。とにかくラインブレーキング・アルゴリズムに適用可能な設定を列挙してみましょう。あなたはこれらについてよく知っているものとします。

\noindent• \code{linebreak.tolerance}：アルゴリズムによって分割点が却下されるまでの限界値です。（デフォルト：500）

\noindent• \code{linebreak.pretolerance}：これよりも良い分割点がければ、ハイフネーションが検討されます（デフォルト：100）

\noindent• \code{linebreak.adjdemerits}：ふたつの引き続く行が視覚的に不整合であった場合に、パラグラフ構築中に累積される付加的なデメリット値の量です。このケースでは、ジャスティフィケーションのためによるスペーシングの不均一のために起こります。\footnote{訳注：よく分かりません。原文：Additional demerits which are accumulated in the course of paragraph building when two consecutive lines are visually incompatible. In these cases, one line is built with much space for justification, and the other one with little space.}（デフォルト：10000）

\noindent• \code{linebreak.looseness}：現在のパラグラフの行数が、通常よりどのくらい多くなるべきか設定します。（デフォルト：0）

\noindent• \code{linebreak.prevGraf}：現在のパラグラフにおいて、垂直リストに追加された行数。

\noindent• \code{linebreak.emergencyStretch}：パラグラフの各行に追加されるかもしれないストレッチの量。

\noindent• \code{linebreak.linePenalty}：各ラインブレークに付随したペナルティの値。（デフォルト：10）

\noindent• \code{linebreak.hyphenPenalty}：ハイフネーションに伴うペナルティの値。（デフォルト：50）

\noindent• \code{linebreak.doubleHyphenDemerits}：連続した行がともにハイフンで分割される場合のペナルティ。（デフォルト：10000）

\section{Luaからの設定}

これらの設定をSILEレイヤで操作することはまずないでしょう。複雑なレイアウトコマンドはLuaスクリプトで実装されることが想定されています。以下のSILE関数がLuaからアクセス可能です。

\noindent• \code{SILE.settings.set(\em{<parameter>}, \em{value})}：パラメータの設定を行います。

\note{
SILEレイヤでは、\code{\\set}コマンドは文字列による表現を、可能な限り適切なLua型に変換してくれますが、\code{SILE.settings.set}はそれを行いません。Luaではパラメータは適切な型で与えられることが想定されています。例えば、長さは\code{SILE.Length}オブジェクトでグルーは\code{Glue}でなければなりません。}

\noindent• \code{SILE.settings.get(\em{<parameter>})}：現在のパラメータの設定を取得します。

\noindent• \code{SILE.settings.temporarily(\em{function})}：すべての設定を一旦保存し、関数を実行した後、それを回復します。

\noindent• \code{SILE.settings.declare(\em{<specification>})}：新たな設定パラメータを宣言します。使い方については、例として\code{settings.lua}における基本的な設定を参照してください。クラスパッケージは名前空間を用い、\code{<package>.<setting>}とすべきです。

\chapter{SILEの内部}

我々のSILEに関する探索は、そろそろ最深部にたどり着きました。ここからは、SILEのすべての基礎となる、基本的構成要素についてみていきましょう。

\note{ここでは、あなたはクラスの設計者であるとしましょう。あなたはSILEがこれから説明するコマンドや機能をどう実装しているかについての細部を、きちんと理解できるようになるものとしましょう。我々はまた、Luaレベルでこのコンポーネントにどうアクセスするのか見るでしょう。}

\section{ボックスとグルー、ペナルティ}

SILEの仕事は、大雑把に言うと、小さなボックスをページに配置するだけのことです。これらのボックスのうちいくつかは、その内部に文字を持ち、そしてそれらの文字はある幅や高さを持ち、またボックスはスペースを占有するだけで空っぽであったりします。ボックスの、ひとつの水平な集まりが出来上がる（つまりラインブレークが起こる）と、それは別のボックスの中に押し込まれ、それらが集まってできるボックスの垂直なリストは、ページを構成するよう配置されます。

概念的に、SILEはいくつかの基本的なコンポーネントを知っています。水平ボックス（文字など）、水平グルー（伸縮可能な単語間のスペース）、垂直ボックス（テキストから構成される行）、垂直グルー（行間やパラグラフ間のスペース）、そしてペナルティ（いかなるときに行やページを分割するかの情報）です。\footnote{これらに加えて、あと3つのボックスの種類があります。N-ノード、アンシェイプド・ノード、そしてディスクレショナリー（任意の）ノードです。}

とにかく使い勝手がいいのは、水平および垂直グルーです。SILEの入力ストリームに直接これらのグルーを挿入するには、\code{\\glue}と\code{\\skip}コマンドを使います。水平・垂直グルーはそれぞれ、\code{width}と\code{height}パラメータを取ります。このパラメータはグルー・ディメンジョン（寸法）です。例えば、\code{\\smallskip}コマンドは、\code{\\skip[height=3pt plus 1pt minus 1pt]}で、\code{\\thinspace}は\code{\\glue[width=0.16667em]}と定義されています。

同様に、\code{\\penalty}コマンドが、ペナルティノードを挿入するのに使えます。\code{\\break}は\code{\\penalty[penalty=-10000]}と、\code{\\nobreak}は\code{\\penalty[penalty=10000]}と定義されています。

水平あるいは垂直ボックスを生成することもできます。これを行うひとつの明白な動機は、改ページや改行によって分割されて欲しくないものがあることでしょう。別の理由としては、一度ボックスとして構築されると、それがどのくらいの大きさを占めるのかが明らかになることです。\code{\\hbox}と\code{\\vbox}コマンドはその内容をボックスに配置し、Luaから呼び出されるときは新たなボックスを\em{返し}（\em{return}し）ます。

\subsection{Luaインターフェイス}

SILEのLuaインターフェイスには、ボックスとグルーを扱うための\code{nodefactory}があります。この話題に移る前に、次のことを理解しておいてください。グルー量は常に\code{SILE.length}オブジェクトで指定されます。これは、基本長とストレッチ、シュリンクの3要素からなるという意味での「3次元」量です。\code{SILE.length}を構築するには、

\begin{verbatim}
\line
local l = SILE.length.new(\{ length = x, stretch = y, shrink = z\})
\line
\end{verbatim}

\noindent{}のようにします。

水平グルーや垂直グルーを作るには、

\begin{verbatim}
\line
local glue  = SILE.nodefactory.newGlue (\{ width =  l\})
local vglue = SILE.nodefactory.newVglue(\{ height = l\})
\line
\end{verbatim}

SILEの組版エンジンは\code{SILE.typesetter}オブジェクトにより構成されます。これはふたつのキューを管理します—ノードキュー（\code{SILE.typesetter.state.nodes}）は、すぐに行に分割されることになる、新たな水平ボックスと水平グルーの集まりです。出力キュー（\code{SILE.typesetter.state.outputQueue}）はページに分割されることになる垂直要素（行）から構成されます。ラインブレーキングやページブレーキングはタイプセッタが水平モードと垂直モードの間を遷移する際に起こります。あなたはこれを\code{SILE.typesetter:leaveHmode()}で強制することができます。SILEレベルでは、パラグラフの終了を強制するコマンドは\code{\\par}です。

あなたが垂直なスペースを加えたいとしましょう。この場合、まずは\code{SILE.typesetter:leaveHmode()}によって、現在のパラグラフの処理対象が適切にボックス化され、出力キューに送られることを確実にします。その後あなたは、望みのグルーを出力キューに加えることができます。

ボックスとグルーをキューに送るということは、よくあるオペレーションで、そのための特別なメソッドが存在します。

\begin{verbatim}
\line
SILE.typesetter:leaveHmode()
SILE.typesetter:pushVglue(\{ height = l \})
\line
\end{verbatim}

ボックスをキューに追加することはやや複雑です。なぜならボックスは何らかのやり方でページに描画される必要があるからです。これを容易にするために、ボックスは通常、\code{value}と\code{outputYourself}メンバ関数を備えます。例えば、\code{image}パッケージはこれを非常に単純なやり方で実現します。画像の幅と高さ、画像のソース、画像を表示するための出力エンジンへの指示、を記した水平ボックスをノードキューに送ります。

\begin{verbatim}
\line
SILE.typesetter:pushHbox(\{
  width= \dots,
  height= \dots,
  depth= 0,
  value= options.src,
  outputYourself= function (this, typesetter, line)
    SILE.outputter.drawImage(this.value,
      typesetter.frame.state.cursorX, typesetter.frame.state.cursorY-this.height,
      this.width,this.height
    );
    typesetter.frame:moveX(this.width)
end\});
\line
\end{verbatim}

水平・垂直ペナルティをキューに送るには、単に\code{SILE.typesetter:pushPenalty(\{penalty = x\})}と\code{SILE.typesetter:pushVpenalty(\{penalty = y\})}メソッドを使用します。

\section{フレーム}

既に述べたように、SILEは文章をページ上のフレームに配置します。通常これらのフレームは、文書クラスで定義されています。しかしながら、あなたはフレームをページごとに作ることができます。これを行うには、\code{\\pagetemplate}と\code{\\frame}コマンドを使います。このようなことを行いたい状況というものは、ごく限られているでしょう。しかしながら、これについて理解することは、文書クラスを自らの手で作成するのに役立つでしょう。

例として、二段組みレイアウトを実現したいとしましょう。SILEはフレームを宣言するのに、\em{constraint solver}\footnote{制約（constraint）を解決する（solve）}システムを利用しています。あなたがフレームが互いにどのように関係しているかをSILEに教えると、SILEはページ上にそれがどのように配置されるべきか計算して教えてくれます。

具体的な手順を見てみましょう。まずは改ページから始まります。なぜならSILEは、ページにテキストを配置し始めた後にページレイアウトを変えることを許可しないからです。\footnote{もちろんあなたは\code{frametricks}パッケージを使ってこの制限を回避することができます—現在のフレームを分割し、\code{frametricks}がこしらえた新たなフレームを操るのです。}どのようにして新しいページを始めることができたでしょう？\code{\\eject}（垂直モード中の\code{\\break}の別名）が出力キューにペナルティを加えるのみであることを思い出してください。そして、改ページは水平モードを去るときに引き起こされます。それを行うには\code{\\par}です。つまり、\code{\\eject\\par}をした後に、\code{\\pagetemplate}を開始できます。
\code{\\pagetemplate}の中では、我々はSILEにどのフレームを用いるのか指示する必要があります。

\begin{verbatim}
\line
\\eject\\par
\\begin[first-content-frame=leftCol]\{pagetemplate\}
\line
\end{verbatim}

それでは段を宣言しましょう。その前にまず段間を宣言します。なぜならそれは既知のものとして定義可能だからです。ここではそれを、ページ幅の3\%としましょう。

\begin{verbatim}
\line
\\frame[id=gutter,width=3\%]
\line
\end{verbatim}

\begin{note}%
フレームのサイズは通常の\code{<dimension>}で記述されます。加えて以下の3つも可能です。

\noindent• 他のフレームのプロパティを\code{top()}、\code{bottom()}、\code{left()}、\code{right()}、\code{height()}、\code{width()}関数で参照することができます。この関数はフレームIDを引数にとります。SILEではフレーム\code{page}が定義済みとなっており、これによりページ全体のサイズにアクセスできます。

\noindent• 算術関数が利用可能です。plus、minus、divide、multiply、そして括弧は数式でのそれと同じ意味を持ちます。フレーム\code{b}がフレーム\code{a}の半分の高さに5ミリ加えたものであると宣言するには、\code{height=5mm + (height(b) / 2)}とします。しかしながら、後に見るように、SILEにこのような計算を任せるようにしたほうがよいでしょう。

\noindent• 版面のデザインはしばしばページに対する割合で指定されるため、ショートカットとして、\code{width=5\%}を\code{width=0.05 * width(page)}の代わりに、\code{height=50\%}を\code{height=0.5 * height(page)}の代わりに使うことができます。SILEはあなたが垂直・水平どちらの割合指定をおこなうつもりなのか、判断できます。

\end{note}

次に左右の段のためのフレームを準備しましょう。\code{book}クラスは既にいくつかのフレームを定義しています。ひとつは\code{content}で、本文用にちょうど良いサイズと位置に配置されています。我々は、このフレームの境界を段の宣言に使います。左段の左マージンはこのフレームの左マージンで、右段の右マージンはこれの右マージンです。また、我々の目的には追加のパラメータが必要となります。なぜなら以下の要件、

\noindent• 段間の余白はふたつの段の間に配置される。

\noindent• ふたつの段は同じ幅を持つ。（この幅は明らかではないが、SILEがうまくやってくれる）

\noindent• 左段がいっぱいになったら、右段に移動して文章を続ける。

\noindent{}を満たす必要があるからです。

\begin{verbatim}
\line
\\frame[id=leftCol, left=left(r), right=left(gutter),
       top=top(r), bottom=bottom(r),
       next=rightCol]
\\frame[id=rightCol, left=right(gutter), right=right(r),
       top=top(r), bottom=bottom(r),
       width=width(leftCol)]
\line
\end{verbatim}

そして、ようやく\code{pagetemplate}を完了させます。

\begin{verbatim}
\line
\\end\{pagetemplate\}
\line
\end{verbatim}

実際に試してみましょう。
\eject\par%
\begin[first-content-frame=leftCol]{pagetemplate}
\frame[id=gutter,width=3%]
\frame[id=leftCol,left=left(content),right=left(gutter),top=top(content),bottom=bottom(content),next=rightCol]
\frame[id=rightCol,left=right(gutter),right=right(runningHead),top=top(content),bottom=bottom(content),width=width(leftCol)]
\end{pagetemplate}
\showframe[id=leftCol]\showframe[id=rightCol]

このページは2段組みになっています。

次の章では、フレームの宣言に関する知識を、独自の文書クラスを作成するために役立ててみましょう。とりあえず、段組みがきちんとできていることを示すために、ダミーの文章を流しておきましょう。

\lorem[words=500]

\chapter{文書クラスの設計}

\changed

ひとつのページ上でフレームレイアウトを定義する方法を学んだところで、文書全体でそれを定義する方法へと進みましょう。

文書クラスはLuaファイルで、それはカレントディレクトリ、あるいはSILE検索パス（典型的には\code{/usr/local/share/sile}）の\code{classes/}サブディレクトリに置きます。 それでは、マージンと本文領域\footnote{訳注：版面。原文はtypeblockです。}のサイズを変えるだけの、単純なクラスを作成してみましょう。我々はこれを\code{bringhurst.lua}と名付けます。なぜならばこれは、Hartley
& Marks版、Robert Bringhurstによる『The Elements of Typographical Style』のレイアウトを模倣するからです。

我々が設計するのは、書籍用のクラスです。このためSILEの\code{book}クラス、\code{classes/book.lua}、を継承するとよいでしょう。

ざっと\code{book.lua}の内容を覗いてみましょう。最初のクラス定義の後、\code{masters}パッケージを読み込んでいます。そしてマスタを以下のフレームとして定義します。（可読性のために適宜、改行を入れています）

\begin{verbatim}
\line
book:defineMaster(\{
  id = "right",
  firstContentFrame = "content",
  frames = \{

    content = \{
      left = "8.3\%", right = "86%",
      top = "11.6\%", bottom = "top(footnotes)"
    \},

    folio = \{
      left = "left(content)", right = "right(content)",
      top = "bottom(footnotes)+3\%",bottom = "bottom(footnotes)+5\%"
    \},

    runningHead = \{
      left = "left(content)", right = "right(content)",
      top = "top(content) - 8\%", bottom = "top(content)-3\%"
    \},

    footnotes = \{
      left ="left(content)", right = "right(content)",
      height = "0", bottom="83.3\%"
    \}
  \}
\})
\line
\end{verbatim}

4つのフレームが宣言されていることが分かります。最初のは本文用のフレームで、SILEでは約束事として\code{content}と呼びます。\code{content}フレームの下部に隣接するのは、\code{footnotes}フレームです。本文領域の上辺と注釈用フレームの下辺は固定された位置に来ます。しかしながら、本文領域と注釈の間の境界は可変です。初期値として、注釈用フレームの高さはゼロです。（そして本文領域がページの全領域を占めます）注釈が挿入されると、それらの高さは調整されます。

フォリオフレーム(ページ番号の部分)\footnote{訳注：ノンブル} は注釈の下に来ます。そしてヘッダは\code{content}フレームの上に来ます。

次に我々は、\code{twoside}パッケージで右ページと左ページが対になるようにします。

\begin{verbatim}
\line
book:loadPackage("twoside", \{ oddPageMaster = "right", evenPageMaster = "left" \});
book:mirrorMaster("left", "right")
\line
\end{verbatim}

bookクラスはまた、セクショニングのコマンドを提供し、ページの始めと終わりになされるべき様々なことを宣言します。我々はbookクラスから継承しているので、これらはすでに利用可能です。我々がすべきことは、我々の新たなクラスをセットアップし、bookクラスとは異なる部分を定義するのみです。bookクラスを継承するやり方は、

\begin{verbatim}
\line
local book = SILE.require("classes/book")
local bringhurst = book \{ id = "bringhurst" \}
...
return bringhurst
\line
\end{verbatim}

それではフレームマスタの定義に移りましょう。

LaTeXのmemoirクラスにおける『A Few Notes On Book Design』によると、Bringhurstの本では、ノドアキ\footnote{原文は spine margin で、本を見開きにした時の綴じ部付近のマージン。}はページ幅の13分の1で、天、地、小口部分ではそれぞれ、ノドアキの8分の5、16分の5、16分の5です。SILEではこれを次のように設定します。

\begin{verbatim}
\line
bringhurst:defineMaster(\{
  id = "right", firstContentFrame = "content",
  frames = \{
    content = \{
      left = "width(page)/13",
      top = "left(content) * 8 / 5",
      right = "100% - 2*top(content)",
      bottom = "top(footnotes)"
    \},
    folio = \{ ... as before ... \},
    footnotes = \{ ... as before ... \},
    runningHead = \{ ... as before ... \},
    \},
  \}
\})
bringhurst:mirrorMaster("right", "left")
\line
\end{verbatim}

これで完成です！

実際にこれを使ってみると、ヘッダの位置が高過ぎることに気付くでしょう。なぜなら、本文領域が通常のクラスよりも高い位置に配置してあるにも関わらず、ヘッダの位置がそこから相対的に決定されているからです。

それではヘッダの位置を調整し、少し下げてみましょう。

\begin{verbatim}
\line
  runningHead = \{
    left = "left(content)", right = "right(content)",
    top = "top(content) - 4\%", bottom = "top(content)-2\%"
  \},
\line
\end{verbatim}

ともかく、ページの全体的なレイアウトを変えてみたいだけであれば、これで全てです。

\section{コマンドを定義する}

文書クラスを作成するときは、通常、ページの見た目を変える以上のことを行いたくなるでしょう。新たなコマンドを定義したり、出力ルーチンの動作を変更したり、なんらかの状態に関する情報を保存したり調べたり、などです。次の章では実例を挙げて見ていきます。

Luaレベルであなた自身のコマンドを定義するには、\code{SILE.registerCommand}関数を使います。これは3つのパラメータを取ります。コマンド名、コマンドの実装内容である関数、そしてコマンドの説明文です。関数のシグネチャ（呼出し情報）は固定されています。それはふたつのパラメータをとり、
\code{options}と\code{content} （もちろんパラメータ名は自由に選ぶことができます）です。これらのパラメータはどちらもLuaテーブルです。\code{options}パラメータはコマンドのパラメータか、キーと値のテーブルとして与えられるXML属性値です。\code{content}は現在処理中の入力からなる、抽象構文木です。

つまり、\code{\\mycommand[size=12pt]\{Hello \\break world\}}の場合、最初のパラメータはテーブル\code{\{size = "12pt"\}}で、2番目のパラメータは以下のようなテーブルとなります。

\begin{verbatim}
\line
\{
  "Hello ",
  \{
    attr = \{\},
    id = "command",
    pos = 8,
    tag = "break"
  \},
  " world"
\}\line
\end{verbatim}

ほとんどのコマンドは結局、なんらかの形で\code{options}を処理し、あるいは場合によっては、\goodbreak\code{SILE.process(content)}により再帰的に、与えられたコマンド引数を処理することになります。ごく簡単な例を挙げてみましょう。XML \code{<link>}タグはXLink属性 \code{xl:href}\footnote{もちろん、文書の著者は別のXML名前空間を選ぶ可能性があります。ここでは物事を単純化しましょう。}を取ります。 我々は、\code{<link xl:href="http://...">{}Hello</link>}を、\examplefont{Hello (\code{http://...})}と表示したいとしましょう。つまり、まず内容となるテキストを描画し、属性値に対して何らかの処理を行います。

\begin{verbatim}
\line
SILE.registerCommand("link", function(options, content)
  SILE.process(content)
  if (options["xl:href"]) then
    SILE.typesetter:typeset(" (")
    SILE.call("code", \{\}, \{options["xl:href"]\})
    SILE.typesetter:typeset(")")
  end
end)
\line
\end{verbatim}

ここでは、\code{SILE.typesetter:typeset}と\code{SILE.call}関数を使って、テキストの出力と他のコマンドの呼出しを行っています。

\note{ディメンジョン（寸法）を扱う必要がある場合には、\code{SILE.toPoints}で長さを表す量を、\code{SILE.parseComplexFrameDimension}でフレーム寸法をパースし、値をポイントに変換します。}

\section{出力ルーチン}

フレームやパッケージを定義する以外にも、クラスではSILEの出力を行うやり方を変更することができます—ページの始めや終わりで何かを行ったり。例えば、マスタフレームを入れ替えたり、ページ番号を表示したり。


\em{出力ルーチン}を定義する基本的なメソッドは、

\noindent{}• \code{newPar}と\code{endPar}はパラグラフの始めと終わりで呼び出される。

\noindent{}• \code{newPage}と\code{endPage}はページの始めと終わりで呼び出される。

\noindent{}• \code{init}と\code{finish}は文書の始めと終わりで呼び出される。

これはオブジェクト指向的なやり方で行われます。派生クラスはそのスーパークラスのメソッドを、必要であれば書き換えます。

出力ルーチンに影響するパッケージをロードするとき、それらパッケージからクラスが構成されるやり方は、完全には自動化されません。\footnote{イベントの順序が重要だからです。}言い換えると、パッケージのロードそれ自体は、自動的に出力ルーチンをアレンジし、置き換えるわけではありません。あなたは明示的に、これらのパッケージにより提供される機能を、出力ルーチンに組み込んでいく必要があります。

例えば、\code{footnote}や\code{insertions}パッケージは、\code{outputInsertions}メソッドを提供します。これは各ページの末尾に呼び出される必要があります。もしも\code{plain}クラスから継承を行い、かつ脚注機能を使いたい場合、\code{endPage}メソッドを以下のように定義する必要があるでしょう。

\begin{verbatim}
\line
myClass.endPage = function(self)
  myClass:outputInsertions()
  plain.endPage(self)
end
\line
\end{verbatim}

\code{tableofcontents}パッケージを例にとり、それがどのように機能するか、ざっと見てみましょう。我々は、\code{infonodes}パッケージを使って、どのページがに目次に記載されるべきアイテムが現れるのかを調べます。

まずは、セクショニング・コマンドから呼び出されるあるコマンドを作ります。この中で情報ノードを設定します。具体的には、\code{\\chapter}や\code{\\section}などのコマンドは、その章・節の開始位置を含むページへの参照を記録するため、\code{\\tocentry}を呼び出すことにします。

\begin{verbatim}
\line
SILE.registerCommand("tocentry", function (options, content)
  SILE.call("info", \{
    category = "toc",
    value = \{
      label = content, level = (options.level or 1)
    \}
  \})
end)
\line
\end{verbatim}

情報ノードのスコープはページ単位\footnote{訳注：per-page basis}であるため、文書全体に対して有効となる情報を保持するためには、それらを各ページの終わりで、何らかのグローバルな他のテーブルへ移してあげなければなりません。ここでページ番号を記録するのを忘れないようにする必要があります。

\note{SILEは\code{SILE.scratch}変数を、グローバルな情報を保持する目的のために提供します。あなたは自身のクラスやパッケージ用に、その一部を名前空間によって区分化して使います。}

目次ノードを移設するために、ページ末尾で呼び出すルーチンは以下のようなものです。

\begin{verbatim}
\line
SILE.scratch.tableofcontents = \{ \}

-- Gather the tocentries into a big document-wide TOC
local moveNodes = function(self)
  local n = SILE.scratch.info.thispage.toc
  for i=1,#n do
    n[i].pageno = SILE.formatCounter(SILE.scratch.counters.folio)
    table.insert(SILE.scratch.tableofcontents, n[i])
  end
end
\line
\end{verbatim}

これらのアイテムを保持するために、LaTeXのように外部ファイルを使いましょう。目次を出力する際には、このファイルを読み込みます。このためには、文書の終わりで\code{SILE.scratch.tableofcontents}をファイルに書き出します。以下のような\code{finish}出力ルーチンを使いましょう。

\begin{verbatim}
\line
local writeToc = function (self)
  local t = std.string.pickle(SILE.scratch.tableofcontents)
  saveFile(t, SILE.masterFileName .. '.toc')
end
\line
\end{verbatim}

そして、\code{\\tableofcontents}コマンドは、そのファイルが存在すればそれを読み込み、目次ノードを適切な形で整形し、出力します。

\begin{verbatim}
\line
SILE.registerCommand("tableofcontents", function (options, content)
  local toc = loadFile(SILE.masterFileName .. '.toc')
  if not toc then
    SILE.call("tableofcontents:notocmessage")
    return
  end
  SILE.call("tableofcontents:header")
  for i = 1,#toc do
    local item = toc[i]
    SILE.call("tableofcontents:item", \{level = item.level, pageno = item.pageno\}, item.label)
  end
end)
\line
\end{verbatim}

これでほぼ完了です。\code{tableofcontents}パッケージはふたつの関数—\code{moveNodes}と\code{writeToc}—を持ち、これらは、このパッケージを使用するクラスの出力ルーチンの様々な場所で呼び出される必要があります。それではどのようにそれを行うのでしょうか？

\section{エクスポート}

他のクラスやパッケージに機能を提供するパッケージは、その機能を、それを必要とするクラスやパッケージに提供する方法を必要とします。これは\em{エクスポート機構}と呼ばれます。

コマンドを定義するのと同様に、それぞれのパッケージはふたつのエントリ、\code{init}と\code{exports}、からなるLuaテーブルを返すことができます。

\code{init}は初期化の動作を定義し、それはクラスのロード時に（必須ではない）オプションを取ることができます。パッケージが\code{class:loadPackage(package, args)}でロードされると、イニシャライザはふたつの引数と共に呼び出されます。\code{class}と\code{args}です。例えば、\code{twoside}パッケージは、左右のマスタフレームのIDに関する情報を受け取ります。これはページが変わる際に、マスタを切り替えるコードを実装するのに必要です。今の我々の状況では、呼び出し側で\code{infonode}パッケージがロードされるのを確実にする必要があります。

\begin{verbatim}
\line
return \{
  init = function (caller)
    caller:loadPackage("infonode")
  end,
\line
\end{verbatim}

パッケージが返すもうひとつのエントリは\code{exports}で、呼び出し側の名前空間にインポートされる関数とその名前の対からなります。つまり、

\begin{verbatim}
\line
  exports = \{writeToc = writeToc, moveTocNodes = moveNodes\}
\}
\line
\end{verbatim}

\noindent{}となっている場合には、\code{tableofcontents}パッケージをロードするクラスは\code{self:writeToc()}と\code{self:moveTocNodes()}を呼び出すことができます。（エクスポートしたときにリネームされていることに注意）これらのメソッドを出力ルーチンの適切な場面で呼び出すのは、そのクラスの責任です。

\chapter{高度なクラスファイル1: XMLプロセッサとしてのSILE}

今や我々は、任意のXML形式のファイルを、PDFへと変換する実例を解説する段階に来ました。SILEに同梱されているDocBookプロセッサを例にとって見ていきましょう。DocBookは技術文書を作成するためのXML文書形式です。DocBook自身は、それが用いるタグがどのように表示されるべきかについては定めていません。よって我々は、自身で文書の体裁を定めなければなりません。

まずあなたに理解しておいて欲しいことは、\em{2種類}のファイルを扱うことが、物事をずっと容易にするということです。ひとつはTeX風書式のSILEファイルで、もうひとつはLuaコードです。これにより、簡単な仕事はそれに都合の良いフォーマットで処理し、困難な仕事はLuaで扱うことを可能とします。SILEのコマンドライン・オプションで\code{-I \em{classname}}を使うと、SILEはまず\code{\em{classname}.sil}というファイルを探し、そしてそれを処理すべきファイルへのラッパーとして用います。そうして、

\begin{verbatim}
\line
\\begin[papersize=a4,class=\em{classname}]\{document\}%
\line
\end{verbatim}

\noindent{}で文書を始めれば、SILEはまた、いつものように、\code{classes/\em{classname}.lua}をロードします。

それでは、XML要素を描画するSILEコマンドの定義を始めましょう。この作業の大部分は、単純明快なもので、あまりくどくど述べるのはやめましょう。例えば、DocBookは\code{<code>}、\goodbreak\code{<filename>}、\goodbreak\code{<guimenu>}などのタグを定義し、これらは等幅フォントで描画されるべきものです。クラスのカスタマイズを容易にするために、まずはフォントの切り替えをひとつのコマンドで置き換えましょう。

\begin{verbatim}
\line
\\define[command=docbook-ttfont]\{\\font[family=Inconsolata,size=2ex]\{\\process\}\}
\line
\end{verbatim}

そして、\code{<code>}などのタグを定義します。

\begin{verbatim}
\\define[command=code]\{\\docbook-ttfont\{\\process\}\}
\\define[command=filename]\{\\docbook-ttfont\{\\process\}\}
\\define[command=guimenu]\{\\docbook-ttfont\{\\process\}\}
\\define[command=guilabel]\{\\docbook-ttfont\{\\process\}\}
\\define[command=guibutton]\{\\docbook-ttfont\{\\process\}\}
\\define[command=computeroutput]\{\\docbook-ttfont\{\\process\}\}
\end{verbatim}

もしもユーザが異なるフォントでの表示を望むなら、\code{docbook-ttfont}を再定義するだけで済みます。

\section{表題を扱う}

単純なタグのことはこれくらいにして、より興味深い状況に移りましょう。複雑なDocBookマークアップがSILEマクロの単純なフォーマットにすんなりと変換できない場合です。

我々は既に、\code{<link>}タグにおいて、XML属性を処理する必要に出くわしました。ここではそれを繰り返さず、他の複雑な場面を考えましょう。一見、単純だと思える\code{<title>}タグです。このタグの処理で複雑なところは、それが異なる文脈で、時としてひとつの文脈で一度以上、出現し得るところです。例えば、\code{<article><title>...}は\code{<section><title>...}とは異なる表示になるでしょうし、\code{<example>}タグ中では、番号を振りたいでしょう。 \code{<bibliomixed>}バイオグラフィ・エントリの表題では新たなブロックとしてではなく、一連のテキストとして、などなど。

このような状況を扱うために、ここでは\code{<title>}の定義を単純なものにとどめ、\code{<title>}を含む要素（すなわち
\code{<article>}や\code{<example>}）の内容を処理する際にそれぞれ独立に、表題を処理することにします。

それでは\code{<example>}の例を見てみましょう。連番を振るという部分がやや複雑です。

\begin{verbatim}
\line
SILE.registerCommand("example", function(options,content)
  SILE.call("increment-counter", \{id="Example"\})
  SILE.call("bigskip")
  SILE.call("docbook-line")
  SILE.call("docbook-titling", \{\}, function()
    SILE.typesetter:typeset("Example".." ".. SILE.formatCounter(SILE.scratch.counters.Example]))
\end{verbatim}

\code{\\docbook-line}は\code{docbook.sil}で定義された、例題部分を分離するための罫線を引くマクロです。\code{\\docbook-titling}も\code{docbook.sil}で定義されたマクロで、表題とヘッダ用にフォントを設定するものです。 もしもユーザが見た目を変えたければ、それを上書きして定義するようにするだけです。

ここまでは順調です。しかし、どうやって\code{<title>}タグを\code{content}抽象構文木から取り出すのでしょうか？SILEはDOMツリーからその内容を探索するXPathあるいはCSSスタイルセレクタを実装していません。\footnote{もちろんパッチは大歓迎です。}その代わりに\code{SILE.findInTree}というコマンドで、現在のツリーの直下の子要素に含まれる特定のタグを探し出すことができます。

\begin{verbatim}
    local t = SILE.findInTree(content, "title")
    if t then
      SILE.typesetter:typeset(": ")
      SILE.process(t)
\end{verbatim}

ここまでの処理によって、\examplefont{Example 123}を出力し、それから\examplefont{: \em{Title}}を描画することができました。我々は、\code{<title>}タグが、\code{<example>}の内容を処理する際に、再度処理されないようにする必要があります。

\begin{verbatim}
      docbook.wipe(t)
\end{verbatim}

\code{docbook.wipe}は与えられたLuaテーブルのすべての要素をnilにするための補助的な関数です。

\begin{verbatim}
function docbook.wipe(tbl)
  while((#tbl) > 0) do tbl[#tbl] = nil end
end
\end{verbatim}

それでは、タイトルと内容の間に余白を挿入し、内容を処理し、ページに罫線を引くことで\code{<example>}の例を完了させましょう。

\begin{verbatim}
    end
  end)
  SILE.call("smallskip")
  SILE.process(content)
  SILE.call("docbook-line")
  SILE.call("bigskip")
\line
\end{verbatim}

\code{<example>}、\code{<table>}、および\code{<figure>}タグはその構造がよく似ています。連番付の表題を持ち、その内容が後に続くことです。このため実際には、我々は汎用の\code{countedThing}メソッドを定義し、それを使ってこれらのタグを定義することになります。

\section{セクショニング}

DocBookのセクショニングはSILEの\code{book}クラスとは幾分異なります。\code{<section>}タグは入れ子になることができます。副節を開始するには、別の\code{<section>}タグを現在の\code{<section>}の中に挿入するのです。このため、今現在どのレベルにいるのか判断するために、それを追跡するスタックが必要となります。また、\em{各}レベルにおける、現在の節番号を記憶しておく必要もあります。例えば、

\begin{verbatim}
  <section><title>A</title> : \examplefont{1. A}
    <section><title>B</title>: \examplefont{1.1 B}
    </section>
    <section><title>C</title>: \examplefont{1.2 C}
      <section><title>D</title>: \examplefont{1.2.1 D}
      </section>
    </section>
    <section><title>E</title>: \examplefont{1.3 E}
  </section>
  <section><title>F</title>: \examplefont{2. F}
\end{verbatim}

このため、我々は2種類の変数、現在のレベルとこれまで現れたすべてのレベル用のカウンタ、を保持します。新たな\code{section}に入るごとに、現在のレベルを表すカウンタを増加させます。

\begin{verbatim}
\line
SILE.registerCommand("section", function (options, content)
  SILE.scratch.docbook.seclevel = SILE.scratch.docbook.seclevel + 1
\end{verbatim}

現レベルにおけるカウンタも増加させます。それと同時に、現レベルより下位のレベルのカウンタをすべて取り消します。（さもなくば、上の例題における\examplefont{E}は\examplefont{1.3.1}となってしまうでしょう）

\begin{verbatim}
  SILE.scratch.docbook.seccount[SILE.scratch.docbook.seclevel] =
    (SILE.scratch.docbook.seccount[SILE.scratch.docbook.seclevel] or 0) + 1
  while #(SILE.scratch.docbook.seccount) > SILE.scratch.docbook.seclevel do
    SILE.scratch.docbook.seccount[#(SILE.scratch.docbook.seccount)] = nil
  end
\end{verbatim}

そして、表題を探し出し、すべての\code{seccount}を結合した番号を、それに前置して出力します。

\begin{verbatim}
  local title = SILE.findInTree(content, "title")
  local number = table.concat(SILE.scratch.docbook.seccount, '.')
  if title then
    SILE.call("docbook-section-"..SILE.scratch.docbook.seclevel.."-title",\{\},function()
      SILE.typesetter:typeset(number.." ")
      SILE.process(title)
    end)
    docbook.wipe(title)
  end
\end{verbatim}

最後に、タグの内容を処理し、\code{</section>}タグを出ると共に現在のレベルを抜け出します。

\begin{verbatim}
  SILE.process(content)
  SILE.scratch.docbook.seclevel = SILE.scratch.docbook.seclevel - 1
end)
\line
\end{verbatim}

\section{その他の機能}

SILEのDocBookの実装は継続中で、まだできることがあります。リストの基礎的な実装では、同様に入れ子となる要素を扱う必要があります。そこでは、リストの種類とリストのカウンタを各レベルで追跡する、別のスタックを実装することになります。

では\code{<xref>}のように、文書の別の場所を相互参照するものはどうでしょうか？例えば、\code{<xref linkend="ch02"/>}は\examplefont{Chapter 2, “The Second Chapter”}となるべきです。これは\code{infonode}パッケージを使って、章の番号や表題に関する情報を収集することで実現可能です。

\chapter{より進んだ話題}

それではSILEについての我々の探索を、もっとプログラミングが必要となるような、幾分ひねりのきいた状況を考えることで終わりにしましょう。

\note{\notehead{訳注}この章ではやや難解な部分が多いため、適宜原文を脚注に載せることにします。}

\section{並列テキスト}

ファイル\code{examples/parallel.sil}は、マタイによる福音書の第1章からの、英語とギリシャ語の対訳からなります。これは、ふたつの文章を並列して進めるために、\code{diglot}クラスを用います。\code{diglot}クラスでは、\code{\\left}と\code{\\right}コマンドにより、左段と右段それぞれの文章を開始することができます。そして\code{\\sync}コマンドが、ふたつの並列した文章を互いに同期させるために利用できます。これはSILEクラスで何ができるのかを示すちょうどよい例となっているため、それがどのように実装されているのか詳しく見てみましょう。

鍵となる事実は、SILEタイプセッタがオブジェクトであるということです。（オブジェクト指向プログラミングの意味で）通常これはシングルトンです—すなわち、ひとつのタイプセッタが文書全体を組み上げるのに用いられます。しかしながら、それはひとつだけでなければならないという理由はありません。事実、並列テキスト処理を実装するための最も単純な方法は、それぞれの段でそれぞれのタイプセッタを持つことです。これらは処理の様々な段階でやりとりを行います。

それではいつものように、\code{diglot.lua}をフレーム定義とクラスのセットアップから始めましょう。

\begin{verbatim}
\line
local plain = SILE.require("classes/plain");
local diglot = std.tree.clone(plain);
SILE.require("packages/counters");
SILE.scratch.counters.folio = \{ value = 1, display = "arabic" \};
SILE.scratch.diglot = \{\}
diglot:declareFrame("a",    \{left = "8.3\%", right = "48\%",
            top = "11.6\%", bottom = "80\%" \});
diglot:declareFrame("b",    \{left = "52\%",  right = "100\% - left(a)",
            top = "top(a)", bottom = "bottom(a)" \});
diglot:declareFrame("folio",\{left = "left(a)", right = "right(b)",
            top = "bottom(a)+3\%",bottom = "bottom(a)+8\%" \});
\end{verbatim}

そしてそれぞれの段用に、ふたつの新たなタイプセッタを作成し、やりとりするために互いを見つける方法を与えましょう。

\begin{verbatim}
diglot.leftTypesetter = SILE.defaultTypesetter \{\}
diglot.rightTypesetter = SILE.defaultTypesetter \{\}
diglot.rightTypesetter.other = diglot.leftTypesetter
diglot.leftTypesetter.other = diglot.rightTypesetter
\end{verbatim}

それぞれの段は異なるフォントを用います。このため、我々はその情報を保持するコマンドを用意します。\code{\\leftfont}と\code{\\rightfont}マクロは、\code{\\left}と\code{\\right}が実行される際に、\code{\\font}コマンドに渡されるべき情報をオプションとして受け取り、それを保持します。（フォントはタイプセッタ固有の設定としてではなく、グローバル設定として制御されるからです）

\begin{verbatim}
SILE.registerCommand("leftfont", function(options, content)
  SILE.scratch.diglot.leftfont = options
end, "Set the font for the left side")

SILE.registerCommand("rightfont", function(options, content)
  SILE.scratch.diglot.rightfont = options
end, "Set the font for the right side")
\end{verbatim}

次にテキストを適切なタイプセッタに送るためのコマンドを用意します。現在稼働中のタイプセッタは変数\code{SILE.typesetter}に保持されます。多くのコマンドとパッケージがこの変数のメソッドを呼び出します。このため我々は、この変数が、我々が使用したいタイプセッタに設定されていることを確実にする必要があります。また、\code{\\sync}コマンドを用いてパラグラフを手動で扱うようにするため、パラグラフの自動検出を無効にする必要もあります。

\begin{verbatim}
SILE.registerCommand("left", function(options, content)
  SILE.settings.set("typesetter.parseppattern", -1)
  SILE.typesetter = diglot.leftTypesetter;
  SILE.Commands["font"](SILE.scratch.diglot.leftfont, \{\})
end, "Begin entering text on the left side")

SILE.registerCommand("right", function(options, content)
  SILE.settings.set("typesetter.parseppattern", -1)
  SILE.typesetter = diglot.rightTypesetter;
  SILE.Commands["font"](SILE.scratch.diglot.rightfont, \{\})
end, "Begin entering text on the right side")
\end{verbatim}

\code{diglot}パッケージの要点は\code{sync}コマンドにあります。このコマンドはふたつのタイプセッタが並んで進むことを保証します。\code{sync}が呼ばれる度に、我々はそれらがページ上の並行した位置にいることを保証する必要があります。具体的に言うと、もしも左段のタイプセッタが右段のそれよりもより下方に進んでいるならば、右段のタイプセッタはいくらかの余白をそのキューに挿入し、同期し直します。その逆も然りです。

SILEのページビルダは\code{SILE.pagebuilder.collateVboxes}と呼ばれるメソッドを持ち、複数の垂直ボックスをひとつにまとめ上げることができます。我々はこれを、それぞれのタイプセッタの出力キューにある垂直ボックスをまとめて、その高さを計るために用いましょう。（出力キューにあるボックスの高さをひとつづつ足しあげて、高さを計算することもできますが、ここで採用する方法ではより簡潔に同じことを成し遂げます）

\begin{verbatim}
SILE.registerCommand("sync", function()
  local lVbox = SILE.pagebuilder.collateVboxes(diglot.leftTypesetter.state.outputQueue)
  local rVbox = SILE.pagebuilder.collateVboxes(diglot.rightTypesetter.state.outputQueue)
  if (rVbox.height > lVbox.height) then
    diglot.leftTypesetter:pushVglue(\{ height = rVbox.height - lVbox.height \})
  elseif (rVbox.height < lVbox.height) then
    diglot.rightTypesetter:pushVglue(\{ height = lVbox.height - rVbox.height \})
  end
\end{verbatim}

そして次にそれぞれのパラグラフを終了させ（\code{parskips}が邪魔にならないように、グルーを付加した後にこれを行います）、パラグラフ処理を通常のものに戻します。

\begin{verbatim}
  diglot.rightTypesetter:leaveHmode();
  diglot.leftTypesetter:leaveHmode();
  SILE.settings.set("typesetter.parseppattern", "\\n\\n+")
end)
\end{verbatim}

これで出力ルーチン以外はすべて完了です。出力ルーチンでは、文書の開始やページの開始で、それぞれのタイプセッタが適切なフレームに充てられていることを保証する必要があります。

\begin{verbatim}
diglot.init = function(self)
  diglot.leftTypesetter:init(SILE.getFrame("a"))
  diglot.rightTypesetter:init(SILE.getFrame("b"))
  return SILE.baseClass.init(self)
end
\end{verbatim}

\noindent{}(\code{SILE.getFrame}は宣言されたフレームのオブジェクトを取得します)

デフォルトの\code{newPage}ルーチンは、一方のタイプセッタに対しては新たなページの開始でこれを行ってくれますが、もう一方に対してはどうしたらよいのか知りません。このため我々は、どちらのタイプセッタが改ページのイベントを発しようとも、もう一方のタイプセッタが適切に初期化されるようにする必要があります。

\begin{verbatim}
diglot.newPage = function(self)
  plain.newPage(self)
  if SILE.typesetter == diglot.leftTypesetter then
    SILE.typesetter.other:initFrame(SILE.getFrame("b"))
    return SILE.getFrame("a")
  else
    SILE.typesetter.other:initFrame(SILE.getFrame("a"))
    return SILE.getFrame("b")
  end
end
\end{verbatim}

最後に、一方のタイプセッタがページ終了のイベントを発した時に、もう一方のタイプセッタにキューを処理する機会を与えてあげなければなりません。

\begin{verbatim}
diglot.endPage = function(self)
  SILE.typesetter.other:leaveHmode(1)
  plain.endPage(self)
end
\end{verbatim}

文書の終わりでも同様の処理を行います。ただし、この場合は\code{leaveHmode}ではなく、緊急の\code{chuck}メソッドを用います。\code{leaveHmode}は「ページビルダーを呼び出し、ページを構築するのに十分なものがあるか見る」のに対し、\code{chuck}は「ここですべてのキューを処理して完了させる」という意味となります。我々は、無限の高さをもつ垂直グルーをもう一方のタイプセッタのキューに与えることでこの過程を補助します。\footnote{訳注：原文はSimilarly for the end of the document, but in this case we will use the
emergency \code{chuck} method; whereas \code{leaveHmode} means “call the
page builder and see there’s enough material to build a page”, \code{chuck}
means “you must get rid of everything on your queue now.” We add some infinitely
tall glue to the other typesetter’s queue to help the process along:}

\begin{verbatim}
diglot.finish = function(self)
  table.insert(SILE.typesetter.other.state.outputQueue, SILE.nodefactory.vfillGlue)
  SILE.typesetter.other:chuck()
  plain.finish(self)
end
\end{verbatim}

これで並列テキストを、ふたつのタイプセッタでうまく処理するクラスが完成しました。

\section{傍注}

あるSILEプロジェクトはふたつの異なる種類の傍注（サイドノート）を必要としました。マージンノートとガターノートです。\footnote{訳注：小口側ととじしろ側の注の意か。}

\line
\img[src=documentation/discovery.png,width=width(content)]
\line

傍注は並行テキストの単純な形態とみなすことができます。完全に「並行」な場合は、左右どちらのタイプセッタも固有の「役割」を持ちません—どちらの側もページを満タンにして、もう一方に追いついてくるように指示することができます。傍注の場合は、はっきりとした主となる文章の流れがあり、注の部分は本文領域でのページ付けに対処しなければなりません。

傍注を実装する方法は様々です。たまたまそのプロジェクトでは、マージンノートとガターノートで異なるアプローチをとりました。ガターでは相互参照がごく頻繁に生じ得ます。このため、それらはページに「積み上げ」られる必要があります—ガターノートは\em{少なくとも}それが関連付けられた節（バース）\footnote{訳注：ここでは聖書といった特定の例を想定していると思われる。バースやマーキング等については図を参照。}とは同じレベルにある必要がありますが、相互参照が密集していれば、それはややページの下方に表示される場合があります。マージンにおけるマーキングはその一方で、重ならないように保証される必要があります。

我々はまず、マージンマーキングを見ていきます。ここではそれをゼロ幅の水平ボックス（TeXでは\code{\\special}と呼ばれるもの）として実装します。それは本文の出力ストリームには存在しますが、本文領域の代わりにマージン領域の同じ高さの位置にマーキングとして現れます。図の例では、最初の行の「there」という語の直前に、この特殊な水平ボックスがあります。

まず初めに、我々は適切なマージンフレームを探し出し、その左端を見つける必要があります。

\begin{verbatim}
\line
discovery.typesetProphecy = function(symbol)
  local margin = discovery:oddPage() and
                  SILE.getFrame("rMargin") or SILE.getFrame("lMargin")
  local target = margin:left()
\end{verbatim}

次に、マーキング・シンボルを置くための別のコマンドを呼び出します。こうすることで、書籍のデザイナがLuaファイルを修正することなしに、SILEレベルでシンボルを変更することを可能にします。ここでは、\command{\\hbox}コマンドにシンボルを出力するコマンドを流し込みます。\command{\\hbox}はその結果を返すと共に、タイプセッタの出力キューにそれを送ります。我々はシンボルを本文領域には出力したくはないので、そのノードをキューから取り除き、\code{hbox}変数にそのローカルなコピーを保持します。

\begin{verbatim}
  local hbox = SILE.call("hbox",\{\}, function()
    SILE.call("prophecy-"..symbol.."-mark")
  end)
  table.remove(SILE.typesetter.state.nodes)
\end{verbatim}

我々が出力キューで\em{実際に}行いたいことは、マージンに、マーキングをするための特殊な水平ボックスノードを送ることです。この水平ボックスは現在の行になんら影響を与えません—それは幅や高さ、深さを持ちません—そしてそれは\code{hbox}変数に保持された、シンボルのコピーを内部に持ちます。

\begin{verbatim}
  SILE.typesetter:pushHbox(\{
    width= 0,
    height = 0,
    depth= 0,
    value= hbox,
\end{verbatim}

最後に我々は、この水平ボックスを出力するルーチンを用意します。ボックス出力ルーチンは3つのパラメータを取ります。ボックスそのもの、現在のタイプセッタ（これはそれがどのフレーム上で処理を行っているのか知っており、そしてそのフレームは自身がどこにあるのか知っている）、そしてその行のストレッチとシュリンクを表す変数です（この例ではこれは不要）。\footnote{訳注：原文はFinally we need to write the routine which outputs this hbox. Box
output routines receive three parameters: the box itself, the current
typesetter (which knows the frame it is typesetting into, and the frame
knows whereabouts it has got to), and a variable representing the stretchability
or shrinkability of the line. (We don’t need that for this example.)}

我々の出力ルーチンがすべきことは、⑴現在の水平位置を記録し他のボックスを出力した後にそこに復帰できるようにしておき、⑵すでに算出しておいた左マージンの左端にジャンプし、⑶シンボルを出力するルーチンに\em{自らを}出力させ、⑷もと居た位置に戻る、です。

\begin{verbatim}
    outputYourself= function (self, typesetter, line)
      local saveX = typesetter.frame.state.cursorX;
      typesetter.frame.state.cursorX = target
      self.value:outputYourself(typesetter,line)
      typesetter.frame.state.cursorX = saveX
    end
  \})
\line
\end{verbatim}

これはごく簡便なバージョンの傍注（20行のコードの！）ですが、個々のシンボルが重ならないように保証するには十分です。ガターノートについては—これはより本来の傍注に近いものですが—我々は幾分スマートに処理する必要があります。ここでは並行テキストを扱ったのと同様のアプローチをとりましょう。ふたつのタイプセッタを使用します。

以前と同じように、オブジェクトを生成し、それらを文書の始めで適切なフレームに割り振られるようにします。

\begin{verbatim}
\line
discovery.innerTypesetter = SILE.defaultTypesetter \{\}

discovery.init = function()
  local gutter = discovery:oddPage() and
                 SILE.getFrame("rGutter") or SILE.getFrame("lGutter")
  discovery.innerTypesetter:init(gutter)
  ...
  return SILE.baseClass:init()
end

discovery.newPage = function ()
  ...
  discovery.innerTypesetter:leaveHmode(1)
  local gutter = discovery:oddPage() and
                 SILE.getFrame("rGutter") or SILE.getFrame("lGutter")
  discovery.innerTypesetter:init(gutter)
  ...
  return SILE.baseClass.newPage(discovery);
end
\line
\end{verbatim}

そして実際に相互参照を扱う関数です。並行テキストの例と同様、ふたつのタイプセッタの出力内容の高さを計ることから始めます。

\begin{verbatim}
\line
discovery.typesetCrossReference = function(xref)
  discovery.innerTypesetter:leaveHmode(1)
  local innerVbox = SILE.pagebuilder.collateVboxes(discovery.innerTypesetter.state.outputQueue)
  local mainVbox = SILE.pagebuilder.collateVboxes(SILE.typesetter.state.outputQueue)
\end{verbatim}

ここでは既に出力キューに送られたもの—すなわち完全なパラグラフ—を取り扱う必要があります。問題となる部分は、ふたつの節の間でパラグラフを終了させたくないという所です。パラグラフの途中で相互参照を処理する際には、我々はその時点での本文の高さが\em{どうなっているべき}かを知る必要があります。\footnote{訳注：原文はif we are mid-paragraph while typesetting
a cross-reference, we need to work out what the height of the material \em{would have
been} if we were to put it onto the output queue at this point.}このため、我々は\code{SILE.typesetter}オブジェクトにいくらか回り道をさせます。

まず始めに、我々は⑴現在のノードキューのコピーを取ります。そして⑵タイプセッタの\code{pushState}メソッドを呼び出します。これにより、タイプセッタを再初期化する一方で、その時点までの状態を後に復元するために保存しておきます。これで新たなタイプセッタが出来上がり、そのキューは空です。このタイプセッタに、⑶これまでのパラグラフの内容を与えてやります。そして⑷水平モードを去るように指示することで、行分割処理を行わせ、行間やパラブラフの高さを計算させます。それから⑸出力キューをボックス化させて、⑹もと居た地点に復帰します。これで我々は、現在のパラグラフを相互参照が挿入される地点まで処理した結果としてのボックスを得ました。⑺このボックスの高さが、相互参照の垂直位置を得るために、\code{mainVbox}に加えるべき距離となります。

\begin{verbatim}
  local unprocessedNodes = std.tree.clone(SILE.typesetter.state.nodes)
  SILE.typesetter:pushState()
  SILE.typesetter.state.nodes = unprocessedNodes
  SILE.typesetter:leaveHmode(1)
  local subsidiary = SILE.pagebuilder.collateVboxes(SILE.typesetter.state.outputQueue)
  SILE.typesetter:popState()
  mainVbox.height = mainVbox.height + subsidiary.height
\end{verbatim}

\note{\code{leaveHmode}に与えられた引数\code{1}は、「ここでは改ページは行わない」という意味となります。}

たいがい、相互参照を出力するためのタイプセッタは本文のタイプセッタと同じ位置まで下りてきていません。このため我々は相互参照タイプセッタに必要な距離だけ移動するように指示します。どちらのタイプセッタも相手に余分な垂直スペースを挿入させ同期することができた、並行テキストの場合とは状況は異なるため、今回は相互参照がややその本来の位置より低めに来たとしてもよしとしましょう。

\begin{verbatim}
  if (innerVbox.height < mainVbox.height) then
    discovery.innerTypesetter:pushVglue(\{ height = mainVbox.height - innerVbox.height \})
  end
\end{verbatim}

この時点で、ふたつのタイプセッタは互いに並んでいるか、相互参照タイプセッタはそれが参照する節より先に進んでいるかのいずれかです。それでは相互参照そのものを出力しましょう。

\begin{verbatim}
  SILE.settings.temporarily(function()
    SILE.settings.set("document.baselineskip", SILE.nodefactory.newVglue("7pt"))
    SILE.Commands["font"](\{size = "6pt", family="Helvetica", weight="800"\}, \{\})
    discovery.innerTypesetter:typeset(SILE.scratch.chapter..":"..SILE.scratch.verse.." ")
    SILE.Commands["font"](\{size = "6pt", family="Helvetica", weight="200"\}, \{\})
    discovery.innerTypesetter:typeset(xref)
    discovery.innerTypesetter:leaveHmode()
    discovery.innerTypesetter:pushVglue(\{ height = SILE.length.new(\{length = 4\}) \})
  end)
end
\line
\end{verbatim}

\note{ここでは\code{SILE.call}は呼びません。なぜならそれは、デフォルトのタイプセッタに作用するからです。もしも物事をより見通し良くしたければ、我々は\code{discovery.innerTypesetter}を\code{SILE.typesetter}に割り当てることでタイプセッタを入れ替え、通常のコマンドを呼ぶこともできます。こうすると、設定やグルーの挿入を「手動で」行う必要がなくなります。}

将来的には、SILEに標準\code{sidenote}パッケージを加えてもよいでしょう。ここではあまり
「標準的ではない」状況をとりあげ、そのようなものを実装するために、SILEの内部処理をどう扱えばよいのか理解するための例題としました。ぜひあなた自身でも何か作ってみましょう！

\section{ライブラリとしてのSILE}

これまではSILEを既存の文書を処理する単独のプロセッサとして実行することを前提としてきました。しかしながら、入力データそのものを生成したり、加工するプログラムの場合に、そのプログラムから直接PDFを生成したいときはどうするのでしょう？そのような状況では、SILEをライブラリとして利用することで、柔軟に、かつ簡単に対応できます。

SILEの配布物の\code{examples/}ディレクトリには、SILEからPDFを生成するLuaスクリプトの例があります。LuaからSILEを使うことは非常に簡単です。困難な部分があるとすれば、それをセットアップすることです。例えば、このように行います。

\begin{verbatim}
\line
require("core/sile")
SILE.outputFilename = "byhand.pdf"
local plain = require("classes/plain")
plain.options.papersize("a4")
SILE.documentState.documentClass = plain;
local ff = plain:init()
SILE.typesetter:init(ff)
\line
\end{verbatim}

SILEのコアライブラリをロードすると、他のすべての部分を同時にロードすることになります。我々は出力ファイル名と、文書を組む際に用いる文書クラスをロードする必要があります。通常のSILE文書と同じく\code{papersize}オプションは必須で、文書クラスの\code{options.papersize}メソッドで用紙サイズを設定します。そしてSILEに、どの文書クラスを実際に使用するのか教える必要があります。文書クラスの\code{init}関数を呼び出して最初のフレームを準備すると、そのフレームでタイプセッタを初期化します。これがSILEに組版処理を行わせるために必要な準備です。

その後はすべてのAPIコールが利用可能です。\code{SILE.call}、\code{SILE.typesetter:typeset}などなど。

\begin{verbatim}
SILE.typesetter:typeset(data)
\end{verbatim}

注意すべき点としては、最後のページの処理を終えるときに、文書クラスの\code{finish}メソッドを呼び出す必要があることでしょうか。

\begin{verbatim}
plain:finish()
\line
\end{verbatim}

\section{デバッギング}

SILEとそのAPIを用いて何かを試みているときには、SILEが何をやっているのかについてのより詳しい情報を知りたくなることがあります。SILEは様々な種類のデバッギング用スイッチを持ち、それらはコマンドラインやLuaコードから有効にすることができます。

SILEを\code{--debug \em{facility}}スイッチ付で実行すると、SILEの処理の特定の領域におけるデバッギングを有効にすることができます。ここで\code{\em{facility}}は、

\noindent{}• \code{typesetter}はタイプセッタの一般的なデバッギング情報を提供します。文字をボックスにしたり、ボックスを行に積み上げたり、行からパラグラフを生成したり、パラグラフを集めてページにしたり。

\noindent{}• \code{pagebuilder}はページ分割を決定する際の問題をデバッグするのに役立ちます。

\noindent{}• \code{break}は行分割アルゴリズムに関するおびただしい量の情報を提供します。

\noindent{}• どのパッケージもそれ独自のデバッギング機能を定義することができます。現在は\code{insertions}のみがそれを行っています。

複数の機能をコンマで区切って指定することで有効化できます。\code{--debug typesetter,break}はタイプセッタと行分割に関するデバッギングを有効にします。

Luaからは\code{SILE.debugFlags}テーブルにエントリを加えることで、特定の機能に関するデバッギングを有効にできます。これは一時的に、特定の操作をデバッギングする際に有用です。

\begin{verbatim}
\line
SILE.debugFlags.typesetter = 1
SILE.typesetter:leaveHmode()
SILE.debugFlags.typesetter = nil
\line
\end{verbatim}

パッケージを作成する際には、\code{SU.debug}関数を呼び出すことで、デバッギング情報を書き出すことができます。（\code{SU}はSILE Utilitiesを意味し、これはSILEで使用される様々な補助的関数を提供します）

\begin{verbatim}
\line
SU.debug("mypackage", "Doing a thing")
\line
\end{verbatim}

時として、LuaコードをSILE環境で実行することも助けになるでしょう。SILEはREPL （read-evaluate-print loop）を備えており、ターミナルからLuaコードを入力すると、その実行結果を出力します。SILEを入力ファイルなしで起動すると、REPLに入ります。

\begin{verbatim}
This is SILE 0.9.0
> \em{l = SILE.length.parse("22mm")}
> \em{l.length}
62.3622054
\end{verbatim}

Luaコマンドの実行中はいつでも、\code{SILE.repl()}を呼び出すことでREPLに入り、いろいろと試すことができます。\code{Ctrl-D}を入力することでREPLを抜け出し、文書の処理に戻ります。

\section{結論}

我々はSILEの基本的な機能だけでなく、SILE APIを使って組版上の困難な問題を解決するために、新たな方向にそれを拡張する例まで見てきました。この調子でさらに続けて、自身のSILEパッケージを作ってみましょう！

\end{document}
